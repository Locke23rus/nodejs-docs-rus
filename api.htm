<!DOCTYPE html>
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<TITLE>node(1) -- Synopsis for V8 JavaScript</TITLE>
	<STYLE type="text/css">
		*{
			margin: 0;padding: 0;
		}
		html,body
		{
			height: 100%;
		}
		body
		{
			font-family:helvetica, arial, sans serif;
			background:#22252a;
			color:#eee;
			font-size:16px;
			line-height:1.3;
			position:relative;
			min-width: 690px;
		}
		a
		{
			color:#CD5;
		}
		a:focus
		{
			outline: none;
			-moz-outline: none;
		}
		pre
		{
			overflow: hidden;
		}
		li
		{
			list-style: inside;
		}
		#man,#man code,#man pre,#man tt,#man kbd,#man samp
		{
			line-height:1.6;
			color:#eee;
			background:#22252a;
		}

		#man
		{
			margin: 0;
			position: absolute;
			top:0;
			bottom:0;
			left: 225px;
			right: 0;
			overflow: auto;
		}
		#man-content
		{
			padding: 0 20px;
			max-width: 650px;
		}
		#man h1,#man h2,#man h3
		{
			color:#DCDDDE;
			clear:left;
		}

		#man h1
		{
			background:url("api-files/logo.png") no-repeat scroll center 0 transparent;
			height:111px;
			margin:15px 0 20px;
			text-align:center;
			text-indent:-2000px;
		}

		#man h2
		{
			font-size:18px;
			background:#000;
			color:#CD5;
			margin:10px 0;
			padding:5px 10px;
		}

		#man h3
		{
			font-size:16px;
			margin:0 0 0 0ex;
		}

		#man p,#man ul,#man ol,#man dl,#man pre
		{
			margin:0 0 18px;
		}

		#man pre
		{
			color:#CCCDCE;
			background:#121314;
			border-left:2ex solid #222;
			margin:0 0 20px;
			padding:5px 7px;
		}

		#man pre + h2,#man pre + h3
		{
			margin-top:22px;
		}

		#man h2 + pre,#man h3 + pre
		{
			margin-top:5px;
		}

		#man > p,#man > ul,#man > ol,#man > dl,#man > pre
		{
			margin-left:5%;
		}

		#man dt
		{
			clear:left;
			margin:0;
		}

		#man dt.flush
		{
			float:left;
			width:8ex;
		}

		#man dd
		{
			margin:0 0 0 9ex;
		}

		#man code,#man strong,#man b
		{
			font-weight:bold;
			color:#ECEDEE;
		}

		#man pre code
		{
			font-weight:normal;
			color:#DCDDDE;
			background:inherit;
		}

		#man em,var,u
		{
			font-style:normal;
			color:#CCCDCE;
			border-bottom:1px solid #999;
		}

		#man ol.man,#man ol.man li
		{
			float:left;
			width:33%;
			list-style-type:none;
			text-transform:uppercase;
			font-size:18px;
			color:#666;
			letter-spacing:1px;
			margin:2px 0 10px;
			padding:0;
		}

		#man ol.man
		{
			width:100%;
		}

		#man ol.man li.tl
		{
			text-align:left;
		}

		#man ol.man li.tc
		{
			text-align:center;
			letter-spacing:4px;
		}

		#man ol.man li.tr
		{
			text-align:right;
		}

		#man ol.man a
		{
			color:#666;
		}

		#man ol.man a:hover
		{
			color:#CCCDCE;
		}

		#toc
		{
			position: absolute;
			top:0;
			bottom:0;
			left: 0;
			padding-left: 30px;
			width: 195px;
			overflow: auto;
			overflow-x: hidden;
			font-size: 15px;
		}
		#toc li
		{
			text-wrap: word-wrap;
		}
		#toc a
		{
			display: inline-block;
			width: 100%;
			color: #fff;
			text-decoration:none;
		}
		#toc > a:hover
		{
			color: rgba(255,255,255,0.7);
		}
		#toc > ul > li
		{
			border-bottom:1px solid #0f1214;
			padding:5px 0 5px 5px;
			list-style: none;
			line-height: 1.3;
		}
		#toc ul ul
		{
			display: none;
		}
		#toc ul ul > li
		{
			border-top:1px solid rgba(0, 0, 0, 0.1);
			color:#FFFFFF;
			font-size:85%;
			line-height:1.3;
			list-style:disc outside none;
			margin-left:25px;
			max-width:165px;
			padding:3px 0 5px 5px;
		}
		#toc li.active > a
		{
			color:#CD5;
		}

		.sh_sourceCode
		{
			font-family: monospace;
			overflow:hidden;
		}

		#toc .toggler
		{
			-moz-user-select:none;
			background:none repeat scroll 0 0 #000000;
			color:#FFFFFF;
			display:inline-block;
			font-weight:bold;
			height:31px;
			line-height:32px;
			margin:-5px 8px -18px -33px;
			outline:medium none;
			padding:0;
			text-align:center;
			width:25px;
		}
		.current-section
		{
			position: fixed;
			top: 0;
			margin: 0 !important;
		}
		#toctitle
		{
			background:none repeat scroll 0 0 #000000;
			color:#CCDD55;
			font-size:18px;
			margin: 0 0 10px -30px;
			padding: 10px;
		}
	</STYLE>
<LINK rel="stylesheet" href="api-files/sh_vim-dark.css" type="text/css">
</HEAD><BODY>

<DIV id="toc">
	<DIV id="toctitle">Node v0.1.100</DIV>
	<NOSCRIPT>Для удобного чтения документации в Вашем браузере должен быть включен JavaScript</NOSCRIPT>
</DIV>

<DIV id="man">
<DIV id="man-content">
<H1 class="man-title">node(1)</H1>

<OL class="head man">
  <LI class="tl">node(1)</LI>

  <LI class="tc">
  <LI class="tr">node(1)</LI>
</OL>
<H2 id="name-0">NAME</H2>
<P><CODE class="sh_sourceCode">node</CODE> -- evented I/O for V8 JavaScript</P>

<H2 id="synopsis-1">Краткий обзор</H2>

<P>Пример web сервера, написанного с помощью Node и отвечающего строкой 'Hello
World':</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> http <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'http'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

http<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">createServer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>request<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> response<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">writeHead</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">200</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Content-Type'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'text/plain'</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">end</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Hello World</SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\n</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">listen</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">8124</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Server running at http://127.0.0.1:8124/'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Чтобы запустить сервер, поместите код в файл с названием <CODE class="sh_sourceCode">example<SPAN class="sh_symbol">.</SPAN>js</CODE> и выполните его программой node</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> node example<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>js
Server running at http<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN><SPAN class="sh_comment"><SPAN class="sh_comment">//127.0.0.1:8124/</SPAN></SPAN>
</CODE></PRE>

<P>Все примеры в этом руководстве можно запустить таким же образом.</P>

<H2 id="standard-modules-2">Стандартные модули</H2>

<P>Вместе с Node поставляется несколько стандартных встроенных модулей,
большинство из которых описано ниже. Стандартный способ использования этих модулей &mdash;
вызов <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'name'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> и сохранение возвращаемого объекта в локальной
переменной с именем, совпадающим с именем модуля.</P>

<P>Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> sys <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Также возможно расширение Node другими модулями. См. <CODE class="sh_sourceCode"><SPAN class="sh_string">'Modules'</SPAN></CODE></P>

<H2 id="buffers-3">Буферы (Buffers)</H2>

<P>Чистый JavaScript поддерживает Unicode, но в нём нет средств для работы с двоичными данными.
При работе с TCP или файловой системой часто необходимо работать именно с потоками двоичных данных.
В Node предусмотрено несколько средств управления, создания и приёма двоичных потоков.</P>

<P>Бинарные данные хранятся в экземплярах класса <CODE class="sh_sourceCode">Buffer</CODE>. <CODE class="sh_sourceCode">Buffer</CODE> похож на
массив целых чисел, но ему соответствует область памяти, выделенная вне стандартной
кучи V8. Размер <CODE class="sh_sourceCode">Buffer</CODE> невозможно изменить после создания.
Подключить класс можно с помощью <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'buffer'</SPAN><SPAN class="sh_symbol">).</SPAN>Buffer</CODE>.</P>

<P>При преобразовании между буферами и строками JavaScript требуется явно указывать
метод кодирования символов. Node поддерживает 3 кодировки для строк: UTF-8 (<CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE>), ASCII (<CODE class="sh_sourceCode"><SPAN class="sh_string">'ascii'</SPAN></CODE>) и
двоичную (<CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE>).</P>

<UL>
<LI><P><CODE class="sh_sourceCode"><SPAN class="sh_string">'ascii'</SPAN></CODE> &mdash; только для 7-битных ASCII-строк.  Этот метод кодирования очень быстрый, и
будет сбрасывать старший бит символа, если тот установлен.</P></LI>
<LI><P><CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE> &mdash; Unicode-символы.  Многие веб-страницы и документы используют UTF-8.</P></LI>
<LI><P><CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE> &mdash; устаревший способ. Хранит двоичные данные в строке используя младшие 8 бит каждого символа. Не используйте эту кодировку.</P></LI>
</UL>


<H3 id="new-buffer-4">new Buffer(size)</H3>

<P>Создаёт новый буфер размера <CODE class="sh_sourceCode">size</CODE> байт.</P>

<H3 id="new-buffer-5">new Buffer(array)</H3>

<P>Создаёт новый буфер, используя массив <CODE class="sh_sourceCode">array</CODE> байт.</P>

<H3 id="new-buffer-6">new Buffer(str, encoding = 'utf8')</H3>

<P>Создаёт новый буфер, содержащий строку <CODE class="sh_sourceCode">str</CODE> в кодировке <CODE class="sh_sourceCode">encoding</CODE>.</P>

<H3 id="buffer-write-7">buffer.write(string, offset=0, encoding='utf8')</H3>

<P>Записывает строку <CODE class="sh_sourceCode">string</CODE> в буфер по смещению <CODE class="sh_sourceCode">offset</CODE> от его начала с использованием указанной кодировки. Возвращает
количество записанных байт. Если <CODE class="sh_sourceCode">buffer</CODE> не имеет достаточно места для сохранения
всей строки метод запишет только её часть. В случае если кодировка строки &mdash; <CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE>, метод не будет записывать частичные символы.</P>

<P>Пример: записать utf8 строку в буфер, потом напечатать его.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">Buffer <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'buffer'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Buffer<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
buf <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">new</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">Buffer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">256</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
len <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> buf<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'</SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\u</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">00bd + </SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\u</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">00bc = </SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\u</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">00be'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>len <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">" bytes: "</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> buf<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">toString</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'utf8'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> len<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// 12 bytes: ½ + ¼ = ¾</SPAN></SPAN>
</CODE></PRE>

<H3 id="buffer-tostring-8">buffer.toString(encoding, start, end)</H3>

<P>Декодирует и возвращает строку из данных буфера, закодированных в кодировке <CODE class="sh_sourceCode">encoding</CODE>
начиная с <CODE class="sh_sourceCode">start</CODE> и заканчивая позицией <CODE class="sh_sourceCode">end</CODE>.</P>

<P>См. пример <CODE class="sh_sourceCode">buffer<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> выше.</P>

<H3 id="buffer[index]-9">buffer[index]</H3>

<P>Получает или устанавливает байт на позиции <CODE class="sh_sourceCode">index</CODE>. Значения соответствуют индивидуальным байтам и могут лежать в пределах от <CODE class="sh_sourceCode"><SPAN class="sh_number">0x00</SPAN></CODE> до <CODE class="sh_sourceCode"><SPAN class="sh_number">0xFF</SPAN></CODE> в шестнадцатиричной записи и от <CODE class="sh_sourceCode"><SPAN class="sh_number">0</SPAN></CODE> до <CODE class="sh_sourceCode"><SPAN class="sh_number">255</SPAN></CODE> в десятичной.

<P>Пример: скопировать ASCII строку в буфер, байт за байтом.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> Buffer <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'buffer'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Buffer<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  str <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">"node.js"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  buf <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">new</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">Buffer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>str<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length<SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
  i<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

<SPAN class="sh_keyword"><SPAN class="sh_keyword">for</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>i <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN> str<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length <SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">+=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  buf<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN>i<SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> str<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">charCodeAt</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>i<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>buf<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// node.js</SPAN></SPAN>
</CODE></PRE>

<H3 id="buffer-bytelength-10">Buffer.byteLength(string, encoding)</H3>

<P>Возвращает количество байт в строке. Это не то же самое что <CODE class="sh_sourceCode"><SPAN class="sh_predef_func">String</SPAN><SPAN class="sh_symbol">.</SPAN><SPAN class="sh_keyword">prototype</SPAN><SPAN class="sh_symbol">.</SPAN>length</CODE> так как этот метод возвращает число <EM>символов</EM> в
строке.</P>

<P>Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> Buffer <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'buffer'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Buffer<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  str <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'</SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\u</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">00bd + </SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\u</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">00bc = </SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\u</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">00be'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>str <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">": "</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> str<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">" characters, "</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN>
  Buffer<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">byteLength</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>str<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'utf8'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">" bytes"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// ½ + ¼ = ¾: 9 символов, 12 байт</SPAN></SPAN>
</CODE></PRE>

<H3 id="buffer-length-11">buffer.length</H3>

<P>Размер буфера в байтах. Заметьте, что это значение не всегда соответствует размеру
содержимого. <CODE class="sh_sourceCode">length</CODE> возвращает объем памяти, зарезервированный
для объекта буфера. Это значение не изменяется при изменении содержимого буфера.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> Buffer <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'buffer'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Buffer<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  buf <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">new</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">Buffer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">1234</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>buf<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
buf<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"some string"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">"ascii"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>buf<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// 1234</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// 1234</SPAN></SPAN>
</CODE></PRE>

<H3 id="buffer-copy-12">buffer.copy(targetBuffer, targetStart, sourceStart, sourceEnd)</H3>

<P>Копирует данные между буферами с помощью <CODE class="sh_sourceCode">memcpy()</CODE>.</P>

<P>Пример: создать два буфера, потом скопировать <CODE class="sh_sourceCode">buf1</CODE> с байта 16 по байт 19
в <CODE class="sh_sourceCode">buf2</CODE>, начиная с 8-го байта в <CODE class="sh_sourceCode">buf2</CODE>.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> Buffer <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'buffer'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Buffer<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  buf1 <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">new</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">Buffer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">26</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
  buf2 <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">new</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">Buffer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">26</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
  i<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

<SPAN class="sh_keyword"><SPAN class="sh_keyword">for</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>i <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">26</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">+=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  buf1<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN>i<SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">97</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> <SPAN class="sh_comment"><SPAN class="sh_comment">// 97 is ASCII a</SPAN></SPAN>
  buf2<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN>i<SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">33</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> <SPAN class="sh_comment"><SPAN class="sh_comment">// ASCII !</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>

buf1<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">copy</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>buf2<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">8</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">16</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">20</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>buf2<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">toString</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ascii'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">25</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// !!!!!!!!qrst!!!!!!!!!!!!!</SPAN></SPAN>
</CODE></PRE>

<H3 id="buffer-slice-13">buffer.slice(start, end)</H3>

<P>Возвращает новый буфер, указывающий на ту же область памяти
что предыдущий, но начиная с <CODE class="sh_sourceCode">start</CODE> и заканчивая <CODE class="sh_sourceCode">end</CODE>
байтами.</P>

<P><STRONG>Изменение содержимого нового буфера затронет содержимое старого!</STRONG></P>

<P>Пример: построить буфер с ASCII-алфавитом, вырезать часть в новый буфер,
затем изменить 1 часть в оригинальном буфере.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> Buffer <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'buffer'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Buffer<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  buf1 <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">new</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">Buffer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">26</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN> buf2<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  i<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

<SPAN class="sh_keyword"><SPAN class="sh_keyword">for</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>i <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">26</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">+=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  buf1<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN>i<SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">97</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> <SPAN class="sh_comment"><SPAN class="sh_comment">// 97 is ASCII a</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>

buf2 <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> buf1<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">slice</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">3</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>buf2<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">toString</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ascii'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> buf2<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
buf1<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">33</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>buf2<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">toString</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ascii'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> buf2<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// abc</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// !bc</SPAN></SPAN>
</CODE></PRE>

<H2 id="eventemitter-14">Источник событий (EventEmitter)</H2>

<P>Множество объектов в Node генерируют события: TCP-сервер генерирует событие
при каждом получении потока данных, дочерний процесс генерирует событие при выходе. Все
объекты, генерирующие события, являются экземплярами <CODE class="sh_sourceCode">events<SPAN class="sh_symbol">.</SPAN>EventEmitter</CODE>.</P>

<P>События представлены строками в стиле camel-case. Вот несколько примеров:
<CODE class="sh_sourceCode"><SPAN class="sh_string">'stream'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'messageBegin'</SPAN></CODE>.</P>

<P>К объектам могут быть присоединены функции, которые будут выполняться при
генерации события. Эти функции называются <EM>обработчиками</EM> (<EM>listeners</EM>).</P>

<P>Класс <CODE class="sh_sourceCode">EventEmitter</CODE> находится в модуле <SPAN class="sh_string">'events'</SPAN>: 
<CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">events'</SPAN><SPAN class="sh_symbol">).</SPAN>EventEmitter</CODE>.</P>

<P>Все источники событий генерируют событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'newListener'</SPAN></CODE> когда к ним добавляются новые обработчики.</P>

<P>Когда источник событий сталкивается с ошибкой, типичное поведение &mdash; сгенерировать событие
ошибки <CODE class="sh_sourceCode"><SPAN class="sh_string">'error'</SPAN></CODE>.  События ошибки особенные &mdash; если им не назначен обработчик они выдают на экран текущий стек (stack trace) и завершают программу.</P>

<H3 id="event-newlistener-15">Событие: 'newListener'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>event<SPAN class="sh_symbol">,</SPAN> listener<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Это событие вызывается каждый раз при добавлении обработчика события.</P>

<H3 id="event-error-16">Событие: 'error'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>exception<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Если произошла ошибка, генерируется это событие. Оно отличается от
других &mdash; если ему не назначено ни одного обработчика Node прекратит выполнение
скрипта и напечатает текущий стек как для необработанного исключения.</P>

<H3 id="emitter-addlistener-17">emitter.addListener(event, listener)</H3>

<P>Добавляет обработчик в конец массива обработчиков указанного события.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">server<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'stream'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'someone connected!'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="emitter-removelistener-18">emitter.removeListener(event, listener)</H3>

<P>Удаляет обработчик из массива обработчиков указанного события.
<STRONG>Внимание</STRONG>: изменяет индексы в массиве обработчиков после указанного обработчика.</P>

<H3 id="emitter-removealllisteners-19">emitter.removeAllListeners(event)</H3>

<P>Удаляет все обработчики из массива обработчиков для указанного события.</P>

<H3 id="emitter-listeners-20">emitter.listeners(event)</H3>

<P>Возвращает массив обработчиков для указанного события. Этот массив может быть
использован, например, для удаления обработчиков.</P>

<H3 id="emitter-emit-21">emitter.emit(event, arg1, arg2, ...)</H3>

<P>Выполнит все обработчики события по порядку с указанными аргументами.</P>

<H2 id="streams-22">Потоки</H2>

<P>Поток &mdash; это абстрактный интерфейс, реализуемый многими объектами в Node.
Например, запрос к HTTP-серверу это поток, также как stdout. Потоки
могут быть с возможностью чтения, записи или и того и другого. Все потоки являются экземплярами <CODE class="sh_sourceCode">EventEmitter</CODE>.</P>

<H2 id="readable-stream-23">Поток с возможностью чтения</H2>

<P><STRONG>Поток с возможностью чтения</STRONG> имеет следующие методы, свойства и события.</P>

<H3 id="event-data-24">Событие: 'data'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>data<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE> передаёт обработчику либо <CODE class="sh_sourceCode">Buffer</CODE> (по умолчанию) либо строку если
предварительно был вызван <CODE class="sh_sourceCode"><SPAN class="sh_function">setEncoding</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="event-end-25">Событие: 'end'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда поток получает символ конца файла EOF (FIN в терминологии TCP).
Означает что событий <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE> больше не предвидится. Если поток также
имеет возможность записи, писать данные можно и дальше.</P>

<H3 id="event-error-26">Событие: 'error'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>exception<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется если при приёме данных произошла ошибка.</P>

<H3 id="event-close-27">Событие: 'close'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда соответствующий потоку файловый дескриптор закрывается. Не все потоки
генерируют это событие. (Например, входящий HTTP запрос не генерирует
<CODE class="sh_sourceCode"><SPAN class="sh_string">'close'</SPAN></CODE>.)</P>

<H3 id="event-fd-28">Событие: 'fd'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>fd<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда поток получает файловый дескриптор. Только UNIX потоки
поддерживают этот функционал; остальные никогда не генерируют это событие.</P>

<!--<H3 id="stream-setencoding-29">stream.readable</H3>

<P>Двоичный параметр, по умолчанию принимает значение true, но переключаемый в false после возникновения ошибки, закрытия потока (событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'end'</SPAN></CODE>) или вызова destroy().</P>-->

<H3 id="stream-setencoding-29">stream.setEncoding(encoding)</H3>

<P>Заставляет событие 'data' передавать обработчику строку вместо буфера. <CODE class="sh_sourceCode">encoding</CODE> может быть
<CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'ascii'</SPAN></CODE>, или <CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE>.</P>

<H3 id="stream-pause-30">stream.pause()</H3>

<P>Прекращает поступление событий <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE>.</P>

<H3 id="stream-resume-31">stream.resume()</H3>

<P>Возобновляет поступление событий <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE> после <CODE class="sh_sourceCode"><SPAN class="sh_function">pause</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="stream-destroy-32">stream.destroy()</H3>

<P>Закрывает соответствующий потоку файловый дескриптор. Поток больше не будет генерировать событий.</P>

<H2 id="writable-stream-33">Поток с возможностью записи</H2>

<P>У <STRONG>потока с возможностью записи</STRONG> есть следующие методы, свойства и события.</P>

<H3 id="event-drain-34">Событие: 'drain'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется после вызова метода <CODE class="sh_sourceCode"><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> вернувшего <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE> &mdash;
сигнал о том что можно писать дальше.</P>

<H3 id="event-error-35">Событие: 'error'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>exception<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется при ошибке с исключением <CODE class="sh_sourceCode">exception</CODE>.</P>

<H3 id="event-close-36">Событие: 'close'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда закрывается соответствующий потоку дескриптор.</P>

<H3 id="stream-write-37">stream.write(string, encoding, [fd])</H3>

<P>Записывает строку <CODE class="sh_sourceCode">string</CODE> в указанной кодировке <CODE class="sh_sourceCode">encoding</CODE> в поток. Возвращает <CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE> если
строка попала в буфер ядра. Возвращает <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE> если
буфер ядра полон и данные будут отправлены позже. Когда данные будут отправлены и буфер ядра опустеет,
будет сгенерировано событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'drain'</SPAN></CODE>.
Кодировка по умолчанию принимает значение <CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE>.</P>

<P>Если указан необязательный параметр <CODE class="sh_sourceCode">fd</CODE>, он интерпретируется как файловый
дескриптор для отправки в поток. Это поддерживается только в UNIX
потоках, и просто игнорируется в другом окружении. Когда дескриптор пересылается таким образом,
если он будет закрыт до события 'drain' потока, может быть отправлен повреждённый (закрытый) дескриптор.</P>

<H3 id="stream-write-38">stream.write(buffer)</H3>

<P>То же что выше, но с использованием буфера.</P>

<H3 id="stream-end-39">stream.end()</H3>

<P>Закрывает поток отправкой EOF или FIN.</P>

<H3 id="stream-end-40">stream.end(string, encoding)</H3>

<P>Посылает строку <CODE class="sh_sourceCode">string</CODE> в указанной кодировке <CODE class="sh_sourceCode">encoding</CODE> и закрывает поток отправкой EOF
или FIN. Так можно уменьшить общее число отправленных пакетов.</P>

<H3 id="stream-end-41">stream.end(buffer)</H3>

<P>То же что выше но с использованием буфера.</P>

<H3 id="stream-destroy-42">stream.destroy()</H3>

<P>Закрывает соответствующий потоку файловый дескриптор. Поток больше не будет генерировать событий.</P>

<H2 id="global-objects-43">Глобальные объекты</H2>

<P>Эти объекты доступны в глобальной области видимости и могут быть использованы в любом месте кода.</P>

<H3 id="global-44">global</H3>

<P>Глобальный объект.</P>

<H3 id="process-45">process</H3>

<P>Объект процесса. Большая часть данных процесса находится именно здесь. См. секцию <CODE class="sh_sourceCode"><SPAN class="sh_string">'process object'</SPAN></CODE>.</P>

<H3 id="require-46">require()</H3>

<P>Подключение модулей. См. секцию <CODE class="sh_sourceCode"><SPAN class="sh_string">'Modules'</SPAN></CODE>.</P>

<H3 id="require-paths-47">require.paths</H3>

<P>Массив путей поиска для <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.  Этот массив может быть изменён для добавления пользовательских путей.</P>

<P>Пример: добавить новый путь в начало массива</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">require<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>paths<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">unshift</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/usr/local/node'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>require<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>paths<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// /usr/local/node,/Users/mjr/.node_libraries</SPAN></SPAN>
</CODE></PRE>

<H3 id="__filename-48">__filename</H3>

<P>Имя исполняемого скрипта.  Это абсолютный путь, и не всегда это
будет то же имя, которое было передано в аргументе командной строки.</P>

<H3 id="__dirname-49">__dirname</H3>

<P>Имя директории исполняемого скрипта.</P>

<P>Example: running <CODE class="sh_sourceCode">node example<SPAN class="sh_symbol">.</SPAN>js</CODE> from <CODE class="sh_sourceCode"><SPAN class="sh_regexp">/Users/m</SPAN>jr</CODE></P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>__filename<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>__dirname<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// /Users/mjr/example.js</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// /Users/mjr</SPAN></SPAN>
</CODE></PRE>

<H3 id="module-50">module</H3>

<P>Ссылка на текущий модуль (типа <CODE class="sh_sourceCode">process<SPAN class="sh_symbol">.</SPAN>Module</CODE>). В частности
<CODE class="sh_sourceCode">module<SPAN class="sh_symbol">.</SPAN>exports</CODE> то же самое что объект <CODE class="sh_sourceCode">exports</CODE>. См. <CODE class="sh_sourceCode"><SPAN class="sh_normal">src</SPAN><SPAN class="sh_symbol">/</SPAN>process<SPAN class="sh_symbol">.</SPAN>js</CODE>
для подробной информации.</P>

<H2 id="process-51">process</H2>

<P>Объект <CODE class="sh_sourceCode">process</CODE> &mdash; глобальный и может быть использован в любом месте кода.
Это экземпляр <CODE class="sh_sourceCode">EventEmitter</CODE>.</P>

<H3 id="event-exit-52">Событие: 'exit'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Генерируется перед тем как процесс завершится.  Это хорошее место для
проверок состояния модуля (например, юнит-тестов).  Event loop не будет действовать
после завершения обработчика 'exit', так что таймеры использовать нельзя.</P>

<P>Пример обработки события <CODE class="sh_sourceCode">exit</CODE>:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'exit'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">nextTick</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
   console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'This will not run'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'About to exit.'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="event-uncaughtexception-53">Событие: 'uncaughtException'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется, когда неперехваченное исключение достигает цикла обработки событий. Если
этому событию назначен обработчик, стандартное действие (печать стека
и выход) производиться не будет.</P>

<P>Пример обработки события <CODE class="sh_sourceCode">uncaughtException</CODE>:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'uncaughtException'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Caught exception: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_function"><SPAN class="sh_function">setTimeout</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'This will still run.'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">500</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// Intentionally cause an exception, but don't catch it.</SPAN></SPAN>
<SPAN class="sh_function"><SPAN class="sh_function">nonexistentFunc</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'This will not run.'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Заметьте, что <CODE class="sh_sourceCode">uncaughtException</CODE> это очень грубый механизм для управления
исключениями.  Использование try / catch in your program даст вам больший контроль над
выполнением вашего кода.  В особенности для программ, предназначенных для постоянной работы,
<CODE class="sh_sourceCode">uncaughtException</CODE> может быть очень полезным механизмом безопасности.</P>

<H3 id="signal-events-54">Сигнальные события</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Генерируются когда процесс получает сигнал. См. sigaction(2) для списка
стандартных имён сигналов в POSIX таких как SIGINT, SIGUSR1, и т.д.</P>

<P>Пример обработки сигнала <CODE class="sh_sourceCode">SIGINT</CODE>:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> stdin <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">openStdin</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>

process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'SIGINT'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Got SIGINT.  Press Control-D to exit.'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Простой способ отправки сигнала <CODE class="sh_sourceCode">SIGINT</CODE>: <CODE class="sh_sourceCode">Control<SPAN class="sh_symbol">-</SPAN>C</CODE> в большинстве терминальных программ.</P>

<H3 id="process-stdout-55">process.stdout</H3>

<P>Поток с возможностью записи, представляющий стандартный поток вывода <CODE class="sh_sourceCode">stdout</CODE>.</P>

<P>Пример: определение <CODE class="sh_sourceCode">console<SPAN class="sh_symbol">.</SPAN>log</CODE></P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>log <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>d<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdout<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>d <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'</SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\n</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-openstdin-56">process.openStdin()</H3>

<P>Открывает стандартный поток ввода, возвращает поток с возможностью чтения.</P>

<P>Пример открытия стандартного потока ввода и обработки обоих событий:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> stdin <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">openStdin</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>

stdin<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">setEncoding</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'utf8'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

stdin<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>chunk<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdout<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> chunk<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

stdin<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'end'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdout<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'end'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-argv-57">process.argv</H3>

<P>Массив, содержащий аргументы командной строки.  Первым элементом будет
'node', вторым &mdash; имя JavaScript файла.  Следующие элементы
будут дополнительными аргументами скрипта.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_comment"><SPAN class="sh_comment">// print process.argv</SPAN></SPAN>
process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>argv<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">forEach</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>val<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> index<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> array<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>index <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">': '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> val<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>В результате получим:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">$ node process<SPAN class="sh_number"><SPAN class="sh_number">-2</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>js one two<SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN>three four
<SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> node
<SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_regexp"><SPAN class="sh_regexp">/Users/m</SPAN></SPAN><SPAN class="sh_normal"><SPAN class="sh_normal">jr</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">/</SPAN></SPAN><SPAN class="sh_normal"><SPAN class="sh_normal">work</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">/</SPAN></SPAN><SPAN class="sh_normal"><SPAN class="sh_normal">node</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">/</SPAN></SPAN>process<SPAN class="sh_number"><SPAN class="sh_number">-2</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>js
<SPAN class="sh_number"><SPAN class="sh_number">2</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> one
<SPAN class="sh_number"><SPAN class="sh_number">3</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> two<SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN>three
<SPAN class="sh_number"><SPAN class="sh_number">4</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> four
</CODE></PRE>

<H3 id="process-execpath-58">process.execPath</H3>

<P>Абсолютный путь к приложению, запустившему процесс.</P>

<H3 id="process-chdir-59">process.chdir(directory)</H3>

<P>Изменяет текущий рабочий каталог приложения либо генерирует исключение, если изменить каталог не удаётся.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Starting directory: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">cwd</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">());</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">try</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">chdir</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/tmp'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'New directory: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">cwd</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">());</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">catch</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'chdir: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-compile-60">process.compile(code, filename)</H3>

<P>Похоже на <CODE class="sh_sourceCode"><SPAN class="sh_predef_func">eval</SPAN></CODE> за исключением того что можно указать имя файла <CODE class="sh_sourceCode">filename</CODE> для более
понятных сообщениях об ошибках; код <CODE class="sh_sourceCode">code</CODE> не имеет доступа к локальной области видимости. Значение <CODE class="sh_sourceCode">filename</CODE>
будет использовано в качестве имени файла если скомпилированный код распечатает содержимое стека.</P>

<P>Пример использования <CODE class="sh_sourceCode">process<SPAN class="sh_symbol">.</SPAN>compile</CODE> и <CODE class="sh_sourceCode"><SPAN class="sh_predef_func">eval</SPAN></CODE> для выполнения одного и того же кода:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> localVar <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">123</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    compiled<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> evaled<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

compiled <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">compile</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'localVar = 1;'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'myfile.js'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'localVar: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> localVar <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">', compiled: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> compiled<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
evaled <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_predef_func"><SPAN class="sh_predef_func">eval</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'localVar = 1;'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'localVar: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> localVar <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">', evaled: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> evaled<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// localVar: 123, compiled: 1</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// localVar: 1, evaled: 1</SPAN></SPAN>
</CODE></PRE>

<P><CODE class="sh_sourceCode">process<SPAN class="sh_symbol">.</SPAN>compile</CODE> не имеет доступа к локальной области видимости, поэтому <CODE class="sh_sourceCode">localVar</CODE> не меняется.
<CODE class="sh_sourceCode"><SPAN class="sh_predef_func">eval</SPAN></CODE> имеет доступ к локальной области видимости, поэтому <CODE class="sh_sourceCode">localVar</CODE> изменяется.</P>

<P>Пр синтаксической ошибке в <CODE class="sh_sourceCode">code</CODE>, <CODE class="sh_sourceCode">process<SPAN class="sh_symbol">.</SPAN>compile</CODE> завершает работу node.</P>

<P>См. также: <CODE class="sh_sourceCode">Script</CODE></P>

<H3 id="process-cwd-61">process.cwd()</H3>

<P>Возвращает текущую рабочую директорию процесса.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Current directory: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">cwd</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">());</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-env-62">process.env</H3>

<P>Объект, хранящий окружение пользователя. См. environ(7).</P>

<H3 id="process-exit-63">process.exit(code)</H3>

<P>Завершает процесс с указанным кодом <CODE class="sh_sourceCode">code</CODE>.  Если код пропущен, выходит
со стандартным успешным кодом <CODE class="sh_sourceCode"><SPAN class="sh_number">0</SPAN></CODE>.</P>

<P>Чтобы выйти с кодом "ошибка":</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">exit</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Оболочка, с помощью которой был запущен скрипт в node, должна получить код ошибки 1.</P>

<H3 id="process-getgid-64">process.getgid(), process.setgid(id)</H3>

<P>Получает/устанавливает групповой индикатор процесса. (См. setgid(2).)  Это числовое значение id группы, а не её имя.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Current gid: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">getgid</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">());</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">try</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">setgid</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">501</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'New gid: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">getgid</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">());</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">catch</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Failed to set gid: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-getuid-65">process.getuid(), process.setuid(id)</H3>

<P>Получает/устанавливает пользователя-владельца процесса. (См. setuid(2).)  Это числовой идентификатор, а не имя пользователя.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Current uid: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">getuid</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">());</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">try</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">setuid</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">501</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'New uid: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">getuid</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">());</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">catch</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Failed to set uid: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-version-66">process.version</H3>

<P>Заданное при компиляции свойство, возвращающее версию Node (<CODE class="sh_sourceCode">NODE_VERSION</CODE>).</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Version: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>version<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-installprefix-67">process.installPrefix</H3>

<P>Заданное при компиляции свойство, хранящее директорию, в которую устанавливали node: <CODE class="sh_sourceCode">NODE_PREFIX</CODE>.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Prefix: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>installPrefix<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-kill-68">process.kill(pid, signal)</H3>

<P>Отправляет сигнал процессу. <CODE class="sh_sourceCode">pid</CODE> это идентификатор процесса, <CODE class="sh_sourceCode">signal</CODE> &mdash; строка, обозначающая отправляемый сигнал.  Имена сигналов это строки вроде
'SIGINT' или 'SIGUSR1'.  Если имя сигнала пропущено, отправлен будет сигнал 'SIGINT'.
См. kill(2) для дальнейшей информации.</P>

<P>Заметьте, что хотя функция и называется <CODE class="sh_sourceCode">process<SPAN class="sh_symbol">.</SPAN>kill</CODE>, на самом
деле она просто отправляет сигнал, как и системная команда <CODE class="sh_sourceCode">kill</CODE>.  Отправляемый сигнал
может не только завершать целевой процесс.</P>

<P>Пример процесса, отправляющего сигнал самому себе:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'SIGHUP'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Got SIGHUP signal.'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_function"><SPAN class="sh_function">setTimeout</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Exiting.'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">exit</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">100</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">kill</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>pid<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'SIGHUP'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-pid-69">process.pid</H3>

<P>Идентификатор процесса (PID).</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'This process is pid '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>pid<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-platform-70">process.platform</H3>

<P>Платформа, на которой выполняется node. <CODE class="sh_sourceCode"><SPAN class="sh_string">'linux2'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'darwin'</SPAN></CODE>, и т.д.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'This platform is '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>platform<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-memoryusage-71">process.memoryUsage()</H3>

<P>Возвращает объект, описывающий потребление памяти процессом Node.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> sys <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">inspect</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">memoryUsage</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">()));</SPAN></SPAN>
</CODE></PRE>

<P>В результате получим:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> rss<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">4935680</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> vsize<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">41893888</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> heapTotal<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1826816</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> heapUsed<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">650472</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<P><CODE class="sh_sourceCode">heapTotal</CODE> и <CODE class="sh_sourceCode">heapUsed</CODE> относятся к потреблению памяти движком V8.</P>

<H3 id="process-nexttick-72">process.nextTick(callback)</H3>

<P>На следующей итерации цикла обработки событий запустить указанный обработчик.
Это <EM>не</EM> простой alias для <CODE class="sh_sourceCode"><SPAN class="sh_function">setTimeout</SPAN><SPAN class="sh_symbol">(</SPAN>fn<SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_number">0</SPAN><SPAN class="sh_symbol">)</SPAN></CODE>, это намного более эффективный метод.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">nextTick</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'nextTick callback'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="process-umask-73">process.umask(mask)</H3>

<P>Задаёт и возвращает маску создания файлов процессом. Дочерние процессы
наследуют эту маску от процесса-родителя. Если задан аргумент <CODE class="sh_sourceCode">mask</CODE> возвращает старую маску, иначе &mdash; возвращает текущую.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> oldmask<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> newmask <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0644</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

oldmask <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">umask</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>newmask<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Changed umask from: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> oldmask<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">toString</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">8</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN>
            <SPAN class="sh_string"><SPAN class="sh_string">' to '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> newmask<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">toString</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">8</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
</CODE></PRE>

<H2 id="sys-74">sys</H2>

<P>Эти функции &mdash; часть модуля <CODE class="sh_sourceCode"><SPAN class="sh_string">'sys'</SPAN></CODE>. Используйте <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'sys'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> чтобы получить к ним доступ.</P>

<H3 id="sys-print-75">sys.print(string)</H3>

<P>То же что <CODE class="sh_sourceCode">console<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">log</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> но без перевода строки.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">print</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'String with no newline'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="sys-debug-76">sys.debug(string)</H3>

<P>Синхронный вывод. Заблокирует процесс и выведет строку <CODE class="sh_sourceCode">string</CODE> в поток <CODE class="sh_sourceCode">stderr</CODE> немедленно.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">debug</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'message on stderr'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="sys-log-77">sys.log(string)</H3>

<P>Выводит строку с меткой времени в <CODE class="sh_sourceCode">stdout</CODE>.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Timestmaped message.'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="sys-inspect-78">sys.inspect(object, showHidden, depth)</H3>

<P>Возвращает объект <CODE class="sh_sourceCode">object</CODE> в виде строки, очень удобно для отладки.</P>

<P>Если <CODE class="sh_sourceCode">showHidden</CODE> имеет значение <CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE>, non-numerable свойства тоже будут показаны.</P>

<P>Если передан параметр <CODE class="sh_sourceCode">depth</CODE>, он сообщает <CODE class="sh_sourceCode">inspect</CODE> на какую глубину просмотреть объект прежде чем выдавать результат. Это полезно для больших сложных объектов.</P>

<P>По умолчанию принята глубина просмотра 2.  Чтобы просмотреть объект на неограниченную глубину, передайте
<CODE class="sh_sourceCode"><SPAN class="sh_keyword">null</SPAN></CODE> в качестве значения <CODE class="sh_sourceCode">depth</CODE>.</P>

<P>Пример просмотра всех свойств объекта <CODE class="sh_sourceCode">sys</CODE>:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> sys <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">inspect</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">true</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">null</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
</CODE></PRE>

<H3 id="sys-pump-79">sys.pump(readableStream, writeableStream, [callback])</H3>

<P>Экспериментальный метод</P>

<P>Читает данные из потока <CODE class="sh_sourceCode">readableStream</CODE> и посылает потоку <CODE class="sh_sourceCode">writableStream</CODE>.
Когда <CODE class="sh_sourceCode">writeableStream<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">(</SPAN>data<SPAN class="sh_symbol">)</SPAN></CODE> возвращает <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE> <CODE class="sh_sourceCode">readableStream</CODE> приостанавливается
пока не произойдёт событие <CODE class="sh_sourceCode">drain</CODE> в <CODE class="sh_sourceCode">writableStream</CODE>. <CODE class="sh_sourceCode">callback</CODE> is
вызывается после закрытия <CODE class="sh_sourceCode">writableStream</CODE>.</P>

<H2 id="timers-80">Таймеры</H2>

<H3 id="settimeout-81">setTimeout(callback, delay, [arg, ...])</H3>

<P>Позволяет выполнить переданный <CODE class="sh_sourceCode">callback</CODE> после <CODE class="sh_sourceCode">delay</CODE> миллисекунд. Возвращает ID таймаута &mdash;
<CODE class="sh_sourceCode">timeoutId</CODE> для последующего использования с <CODE class="sh_sourceCode"><SPAN class="sh_function">clearTimeout</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="cleartimeout-82">clearTimeout(timeoutId)</H3>

<P>Отменяет установленный таймаут.</P>

<H3 id="setinterval-83">setInterval(callback, delay, [arg, ...])</H3>

<P>Позволяет выполнять переданный <CODE class="sh_sourceCode">callback</CODE> каждые <CODE class="sh_sourceCode">delay</CODE> миллисекунд.
Возвращает ID интервала &mdash; <CODE class="sh_sourceCode">intervalId</CODE> для использования с <CODE class="sh_sourceCode"><SPAN class="sh_function">clearInterval</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<P>Кроме того, можно передавать аргументы callback'у.</P>

<H3 id="clearinterval-84">clearInterval(intervalId)</H3>

<P>Прекращает действие интервального таймера.</P>

<H2 id="child-processes-85">Дочерние процессы</H2>

<P>Node предоставляет tri-directional <CODE class="sh_sourceCode"><SPAN class="sh_function">popen</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_number">3</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> в классе <CODE class="sh_sourceCode">ChildProcess</CODE>.</P>

<P>С дочерним потоком можно обмениваться данными через <CODE class="sh_sourceCode">stdin</CODE>, <CODE class="sh_sourceCode">stdout</CODE>, и <CODE class="sh_sourceCode">stderr</CODE> в полностью неблокирующем стиле.</P>

<P>Для создания дочернего процесса используйте <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'child_process'</SPAN><SPAN class="sh_symbol">).</SPAN><SPAN class="sh_function">spawn</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<P>С дочерним процессом всегда ассоциированы три потока. <CODE class="sh_sourceCode">child<SPAN class="sh_symbol">.</SPAN>stdin</CODE>,
<CODE class="sh_sourceCode">child<SPAN class="sh_symbol">.</SPAN>stdout</CODE>, и <CODE class="sh_sourceCode">child<SPAN class="sh_symbol">.</SPAN>stderr</CODE>.</P>

<P><CODE class="sh_sourceCode">ChildProcess</CODE> &mdash; экземпляр EventEmitter.</P>

<H3 id="event-exit-86">Событие:  'exit'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>code<SPAN class="sh_symbol">,</SPAN> signal<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Это событие генерируется при завершении дочернего процесса. Если процесс завершён нормально, в <CODE class="sh_sourceCode">code</CODE> передаётся код завершения процесса, иначе передаётся <CODE class="sh_sourceCode"><SPAN class="sh_keyword">null</SPAN></CODE>. Если процесс завершился от принятия сигнала, <CODE class="sh_sourceCode">signal</CODE> &mdash; это строка, содержащая имя сигнала, либо <CODE class="sh_sourceCode"><SPAN class="sh_keyword">null</SPAN></CODE>.</P>

<P>После генерации события 'exit' события <CODE class="sh_sourceCode"><SPAN class="sh_string">'output'</SPAN></CODE> и <CODE class="sh_sourceCode"><SPAN class="sh_string">'error'</SPAN></CODE> больше не будут генерироваться.</P>

<P>See <CODE class="sh_sourceCode"><SPAN class="sh_function">waitpid</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_number">2</SPAN><SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<H3 id="child_process-spawn-87">child_process.spawn(command, args, env)</H3>

<P>Запускает новый процесс с указанной командой <CODE class="sh_sourceCode">command</CODE>, аргументами командной строки и
переменными окружения. Если аргументы пропущены <CODE class="sh_sourceCode">args</CODE> будет пустым массивом, а <CODE class="sh_sourceCode">env</CODE> будет копией <CODE class="sh_sourceCode">process<SPAN class="sh_symbol">.</SPAN>env</CODE>.</P>

<P>Пример запуска <CODE class="sh_sourceCode">ls <SPAN class="sh_symbol">-</SPAN><SPAN class="sh_normal">lh </SPAN><SPAN class="sh_symbol">/</SPAN>usr</CODE>, чтения <CODE class="sh_sourceCode">stdout</CODE>, <CODE class="sh_sourceCode">stderr</CODE>, и получения кода завершения:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> sys   <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
    spawn <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child_process'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>spawn<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    ls    <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">spawn</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ls'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'-lh'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'/usr'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">]);</SPAN></SPAN>

ls<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdout<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">print</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'stdout: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> data<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

ls<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stderr<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">print</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'stderr: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> data<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

ls<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'exit'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>code<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child process exited with code '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> code<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Пример проверки запуска приложения:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> spawn <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child_process'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>spawn<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    child <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">spawn</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'bad_command'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

child<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stderr<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_regexp"><SPAN class="sh_regexp">/^execvp\(\)/</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">test</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">asciiSlice</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length<SPAN class="sh_symbol"><SPAN class="sh_symbol">)))</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Failed to start child process.'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>См. также: <CODE class="sh_sourceCode">child_process<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">exec</SPAN><SPAN class="sh_symbol">()</SPAN></CODE></P>

<H3 id="child-kill-88">child.kill(signal)</H3>

<P>Отправляет сигнал дочернему процессу. Если аргументы не переданы, процессу будет
отправлен сигнал <CODE class="sh_sourceCode"><SPAN class="sh_string">'SIGTERM'</SPAN></CODE>. См. <CODE class="sh_sourceCode"><SPAN class="sh_function">signal</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_number">7</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> для списка возможных имён сигналов.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> spawn <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child_process'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>spawn<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    grep  <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">spawn</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'grep'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ssh'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">]);</SPAN></SPAN>

grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'exit'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>code<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> signal<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child process terminated due to receipt of signal '</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN>signal<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// отправить процессу сигнал SIGHUP</SPAN></SPAN>
grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">kill</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'SIGHUP'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Заметьте, что хотя функция называется <CODE class="sh_sourceCode">kill</CODE>, сигнал отправляемый дочернему процессу
не обязательно его завершит. Метод <CODE class="sh_sourceCode">kill</CODE> просто отправляет сигналы.</P>

<P>См. <CODE class="sh_sourceCode"><SPAN class="sh_function">kill</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_number">2</SPAN><SPAN class="sh_symbol">)</SPAN></CODE></P>

<H3 id="child-pid-89">child.pid</H3>

<P>Идентификатор дочернего процесса.</P>

<P>Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> spawn <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child_process'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>spawn<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    grep  <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">spawn</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'grep'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ssh'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">]);</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'Spawned child pid: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>pid<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdin<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">end</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>
</CODE></PRE>

<H3 id="child-stdin-write-90">child.stdin.write(data, encoding)</H3>

<P>Пишет данные в стандартный поток ввода (<CODE class="sh_sourceCode">stdin</CODE>) дочернего процесса. Второй аргумент необязательный
и указывает кодировку: его возможные значения <CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'ascii'</SPAN></CODE>, и
<CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE>.</P>

<P>Пример: достаточно сложный способ выполнить 'ps ax | grep ssh'</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> sys   <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
    spawn <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child_process'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>spawn<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    ps    <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">spawn</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ps'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ax'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">]),</SPAN></SPAN>
    grep  <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">spawn</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'grep'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ssh'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">]);</SPAN></SPAN>

ps<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdout<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdin<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

ps<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stderr<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">print</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ps stderr: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> data<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

ps<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'exit'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>code<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>code <SPAN class="sh_symbol"><SPAN class="sh_symbol">!==</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ps process exited with code '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> code<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
  grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdin<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">end</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdout<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">print</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stderr<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">print</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'grep stderr: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> data<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'exit'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>code<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>code <SPAN class="sh_symbol"><SPAN class="sh_symbol">!==</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'grep process exited with code '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> code<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="child-stdin-end-91">child.stdin.end()</H3>

<P>Закрывает поток <CODE class="sh_sourceCode">stdin</CODE> дочернего процесса. Это часто приводит к завершению дочернего процесса.</P>

<P>Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> spawn <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child_process'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>spawn<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    grep  <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">spawn</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'grep'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'ssh'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">]);</SPAN></SPAN>

grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'exit'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>code<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child process exited with code '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> code<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

grep<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>stdin<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">end</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>
</CODE></PRE>

<H3 id="child_process-exec-92">child_process.exec(command, [options, ] callback)</H3>

<P>Высокоуровневый способ выполнить команду в качестве дочернего процесса, сохраняя весь её вывод, и
передать его в callback.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> sys   <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
    exec  <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'child_process'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>exec<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    child<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

child <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">exec</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'cat *.js bad_file | wc -l'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>error<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> stdout<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> stderr<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">print</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'stdout: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> stdout<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
    sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">print</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'stderr: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> stderr<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
    <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>error <SPAN class="sh_symbol"><SPAN class="sh_symbol">!==</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">null</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
      console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'exec error: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> error<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
    <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Функция-callback получает аргументы <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>error<SPAN class="sh_symbol">,</SPAN> stdout<SPAN class="sh_symbol">,</SPAN> stderr<SPAN class="sh_symbol">)</SPAN></CODE>. При удачном выполнении, в <CODE class="sh_sourceCode">error</CODE>
будет <CODE class="sh_sourceCode"><SPAN class="sh_keyword">null</SPAN></CODE>.  При ошибке, <CODE class="sh_sourceCode">error</CODE> будет экземпляром <CODE class="sh_sourceCode"><SPAN class="sh_predef_func">Error</SPAN></CODE>, <CODE class="sh_sourceCode">err<SPAN class="sh_symbol">.</SPAN>code</CODE>
будет кодом завершения дочернего процесса, и в <CODE class="sh_sourceCode">err<SPAN class="sh_symbol">.</SPAN>signal</CODE> будет содержаться имя сигнала, завершившего процесс.</P>

<P>Вторым аргументом могут быть переданы параметры. По умолчанию они будут такими</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> encoding<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'utf8'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> timeout<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> maxBuffer<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">200</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">*</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">1024</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> killSignal<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'SIGKILL'</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<P>Если <CODE class="sh_sourceCode">timeout</CODE> больше 0, процесс будет завершён если он
выполняется дольше чем <CODE class="sh_sourceCode">timeout</CODE> миллисекунд. Дочерний процесс завершается с помощью
сигнала <CODE class="sh_sourceCode">killSignal</CODE> (default: <CODE class="sh_sourceCode"><SPAN class="sh_string">'SIGKILL'</SPAN></CODE>). В <CODE class="sh_sourceCode">maxBuffer</CODE> указывается максимальный объём данных
разрешённый на stdout или stderr &mdash; если этот объём будет превышен, дочерний процесс будет завершён.</P>

<H2 id="script-93">Script</H2>

<P>Модуль <CODE class="sh_sourceCode">Script</CODE> отвечает за компиляцию и запуск JavaScript-кода. Вы можете получить доступ к модулю таким образом:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> Script <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">binding</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'evals'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Script<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
</CODE></PRE>

<P>Новый JavaScript-код может быть скомпилирован и сразу запущен либо скомпилирован, сохранён, и запущен позже.</P>

<H3 id="script-runinthiscontext-94">Script.runInThisContext(code, filename)</H3>

<P>Действует почти как <CODE class="sh_sourceCode">process<SPAN class="sh_symbol">.</SPAN>compile</CODE>.  <CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInThisContext</CODE> компилирует код <CODE class="sh_sourceCode">code</CODE> как если бы он был загружен из файла <CODE class="sh_sourceCode">filename</CODE>,
запускает его и возвращает результат. Запускаемый код не получает доступа к локальной области видимости. Параметр <CODE class="sh_sourceCode">filename</CODE> &mdash; необязательный.</P>

<P>Пример использования <CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInThisContext</CODE> и <CODE class="sh_sourceCode"><SPAN class="sh_predef_func">eval</SPAN></CODE> для запуска одного и того же кода:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> localVar <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">123</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    usingscript<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> evaled<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    Script <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">binding</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'evals'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Script<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

usingscript <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> Script<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">runInThisContext</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'localVar = 1;'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  <SPAN class="sh_string"><SPAN class="sh_string">'myfile.js'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'localVar: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> localVar <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">', usingscript: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN>
  usingscript<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
evaled <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_predef_func"><SPAN class="sh_predef_func">eval</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'localVar = 1;'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'localVar: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> localVar <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">', evaled: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN>
  evaled<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// localVar: 123, usingscript: 1</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// localVar: 1, evaled: 1</SPAN></SPAN>
</CODE></PRE>

<P><CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInThisContext</CODE> не имеет доступа к локальной области видимости, поэтому переменная <CODE class="sh_sourceCode">localVar</CODE> остаётся неизменной.
<CODE class="sh_sourceCode"><SPAN class="sh_predef_func">eval</SPAN></CODE> имеет доступ к локальной области видимости, поэтому <CODE class="sh_sourceCode">localVar</CODE> изменяется.</P>

<P>В случае обнаружения синтаксической ошибки в коде <CODE class="sh_sourceCode">code</CODE>, <CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInThisContext</CODE> выводит текст ошибки в stderr и генерирует исключение.</P>

<H3 id="script-runinnewcontext-95">Script.runInNewContext(code, sandbox, filename)</H3>

<P><CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInNewContext</CODE> компилирует переданный код <CODE class="sh_sourceCode">code</CODE> для запуска в контексте <CODE class="sh_sourceCode">sandbox</CODE> как если бы код был загружен из файла <CODE class="sh_sourceCode">filename</CODE>,
потом выполняет его и возвращает результат. Запущенный код не имеет доступа к локальной области видимости и
объект <CODE class="sh_sourceCode">sandbox</CODE> будет использован в качестве глобального объекта для кода <CODE class="sh_sourceCode">code</CODE>. Параметры <CODE class="sh_sourceCode">sandbox</CODE> и <CODE class="sh_sourceCode">filename</CODE> необязательны.</P>

<P>Пример: скомпилировать и выполнить код, увеличивающий глобальную переменную и создающий новую.
Эти переменные содержатся в sandbox-объекте.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> sys <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
    Script <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">binding</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'evals'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Script<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    sandbox <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
      animal<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'cat'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
      count<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">2</SPAN></SPAN>
    <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

Script<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">runInNewContext</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>
  <SPAN class="sh_string"><SPAN class="sh_string">'count += 1; name = "kitty"'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> sandbox<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'myfile.js'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">inspect</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>sandbox<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// { animal: 'cat', count: 3, name: 'kitty' }</SPAN></SPAN>
</CODE></PRE>

<P>Заметьте, что запуск стороннего кода &mdash; операция, требующая особого внимания. <CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInNewContext</CODE> очень полезен для предотвращения случайных утечек глобальных переменных, но по настоящему безопасное выполнение стороннего кода требует отдельного процесса.</P>

<P>При обнаружении синтаксической ошибки в <CODE class="sh_sourceCode">code</CODE>, <CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInThisContext</CODE> выводит текст ошибки в stderr и генерирует исключение.</P>

<H3 id="new-script-96">new Script(code, filename)</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">new</SPAN> Script</CODE> компилирует переданный код <CODE class="sh_sourceCode">code</CODE> как если бы он был загружен из файла <CODE class="sh_sourceCode">filename</CODE>,
но не запускает его. Вместо этого он возвращает объект <CODE class="sh_sourceCode">Script</CODE> представляющий скомпилированный код.
После этот скрипт может быть многократно выполнен следующими методами.
Возвращаемый скрипт не привязан ни к какому глобальному объекту.
Он привязывается перед каждым запуском, только для этого запуска. <CODE class="sh_sourceCode">filename</CODE> is optional.</P>

<P>В случае обнаружения синтаксической ошибки в коде <CODE class="sh_sourceCode">code</CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_keyword">new</SPAN> Script</CODE> выводит текст ошибки в stderr и генерирует исключение.</P>

<H3 id="script-runinthiscontext-97">script.runInThisContext()</H3>

<P>Похоже на <CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInThisContext</CODE> (обратите внимание на заглавную 'S'), но теперь это метод предварительно скомпилированного объекта Script.
<CODE class="sh_sourceCode">script<SPAN class="sh_symbol">.</SPAN>runInThisContext</CODE> запускает код в объекте <CODE class="sh_sourceCode">script</CODE> и возвращает результат.
У запускаемого кода нет доступа к локальной области видимости, но есть доступ к глобальному объекту <CODE class="sh_sourceCode">global</CODE> (v8: in actual context).</P>

<P>Пример использования <CODE class="sh_sourceCode">script<SPAN class="sh_symbol">.</SPAN>runInThisContext</CODE> чтобы скомпилировать код однажды и запустить несколько раз:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> Script <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">binding</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'evals'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Script<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    scriptObj<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> i<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

globalVar <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

scriptObj <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">new</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">Script</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'globalVar += 1'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'myfile.js'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_keyword"><SPAN class="sh_keyword">for</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>i <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1000</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">+=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  scriptObj<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">runInThisContext</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>globalVar<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// 1000</SPAN></SPAN>
</CODE></PRE>

<H3 id="script-runinnewcontext-98">script.runInNewContext(sandbox)</H3>

<P>Как и в <CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInNewContext</CODE> (note capital 'S'), но теперь это метод заранее созданного объекта Script.
<CODE class="sh_sourceCode">script<SPAN class="sh_symbol">.</SPAN>runInNewContext</CODE> запускает код, содержащийся в объекте <CODE class="sh_sourceCode">script</CODE> с объектом <CODE class="sh_sourceCode">sandbox</CODE> в качестве глобального и возвращает результат.
Запускаемый код не имеет доступа к локальной области видимости. Переменная <CODE class="sh_sourceCode">sandbox</CODE> необязательна.</P>

<P>Пример: скомпилировать и выполнить код, увеличивающий глобальную переменную и создающий новую.
Эти переменные содержатся в sandbox-объекте.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> sys <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'sys'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
    Script <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> process<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">binding</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'evals'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN>Script<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    scriptObj<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> i<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
    sandbox <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
      animal<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'cat'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
      count<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">2</SPAN></SPAN>
    <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

scriptObj <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">new</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">Script</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>
    <SPAN class="sh_string"><SPAN class="sh_string">'count += 1; name = "kitty"'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'myfile.js'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_keyword"><SPAN class="sh_keyword">for</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>i <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">10</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">+=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  scriptObj<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">runInNewContext</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>sandbox<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>

console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">inspect</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>sandbox<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// { animal: 'cat', count: 12, name: 'kitty' }</SPAN></SPAN>
</CODE></PRE>

<P>Заметьте, что запуск стороннего кода &mdash; операция, требующая особого внимания. <CODE class="sh_sourceCode">Script<SPAN class="sh_symbol">.</SPAN>runInNewContext</CODE> очень полезен для предотвращения случайных утечек глобальных переменных, но по настоящему безопасное выполнение стороннего кода требует отдельного процесса.</P>

<H2 id="file-system-99">Файловая система</H2>

<P>File I/O is provided by simple wrappers around standard POSIX functions.  To
use this module do <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'fs'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE>. All the methods have asynchronous and
synchronous forms.</P>

<P>The asynchronous form always take a completion callback as its last argument.
The arguments passed to the completion callback depend on the method, but the
first argument is always reserved for an exception. If the operation was
completed successfully, then the first argument will be <CODE class="sh_sourceCode"><SPAN class="sh_keyword">null</SPAN></CODE> or <CODE class="sh_sourceCode"><SPAN class="sh_predef_var">undefined</SPAN></CODE>.</P>

<P>Here is an example of the asynchronous version:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> fs <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'fs'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">unlink</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/tmp/hello'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">throw</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'successfully deleted /tmp/hello'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Вот пример синхронной версии:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> fs <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'fs'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">unlinkSync</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/tmp/hello'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'successfully deleted /tmp/hello'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Асинхронные методы не гарантируют порядок выполнения операций. Следующий код может сработать неправильно:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">rename</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/tmp/hello'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'/tmp/world'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">throw</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'renamed complete'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stat</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/tmp/world'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> stats<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">throw</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'stats: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> JSON<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>stats<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Вполне возможно что <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>stat</CODE> выполнится до <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>rename</CODE>.
Правильный способ сделать то же самое: выполнение этих методов по цепочке.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">rename</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/tmp/hello'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'/tmp/world'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">throw</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stat</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/tmp/world'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> stats<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">throw</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
    console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'stats: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> JSON<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>stats<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>В нагруженных процессах программисту <EM>строго рекомендуется</EM> использовать
асинхронные версии вызовов. Синхронные версии будут блокировать весь процесс
до своего завершения &mdash; предотвращая любые новые соединения.</P>

<H3 id="fs-rename-100">fs.rename(path1, path2, callback)</H3>

<P>Асинхронное переименование (rename(2)). Обработчику не передаётся аргументов кроме возможного исключения.</P>

<H3 id="fs-renamesync-101">fs.renameSync(path1, path2)</H3>

<P>Синхронный rename(2).</P>

<H3 id="fs-truncate-102">fs.truncate(fd, len, callback)</H3>

<P>Асинхронный ftruncate(2). Обработчику не передаётся аргументов кроме возможного исключения.</P>

<H3 id="fs-truncatesync-103">fs.truncateSync(fd, len)</H3>

<P>Синхронный ftruncate(2).</P>

<H3 id="fs-chmod-104">fs.chmod(path, mode, callback)</H3>

<P>Асинхронное изменение прав доступа (chmod(2)). Обработчику не передаётся аргументов кроме возможного исключения.</P>

<H3 id="fs-chmodsync-105">fs.chmodSync(path, mode)</H3>

<P>Синхронный chmod(2).</P>

<H3 id="fs-stat-106">fs.stat(path, callback), fs.lstat(path, callback), fs.fstat(fd, callback)</H3>

<P>Асинхронные stat(2), lstat(2) или fstat(2). Обработчик получает два аргумента <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> stats<SPAN class="sh_symbol">)</SPAN></CODE> где <CODE class="sh_sourceCode">stats</CODE> это объект <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>Stats</CODE>. Он выглядит примерно так:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> dev<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">2049</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> ino<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">305352</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> mode<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">16877</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> nlink<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">12</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> uid<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1000</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> gid<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1000</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> rdev<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> size<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">4096</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> blksize<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">4096</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> blocks<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">8</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> atime<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'2009-06-29T11:11:55Z'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> mtime<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'2009-06-29T11:11:40Z'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> ctime<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'2009-06-29T11:11:40Z'</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<P>См. секцию <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>Stats</CODE> для дальнейшей информации.</P>

<H3 id="fs-statsync-107">fs.statSync(path), fs.lstatSync(path), fs.fstatSync(fd)</H3>

<P>Синхронные stat(2), lstat(2) и fstat(2). Возвращают экземпляр <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>Stats</CODE>.</P>

<H3 id="fs-link-108">fs.link(srcpath, dstpath, callback)</H3>

<P>Асинхронный link(2). Передаваемой функции не передаётся ничего кроме возможного исключения.</P>

<H3 id="fs-linksync-109">fs.linkSync(dstpath, srcpath)</H3>

<P>Синхронный link(2).</P>

<H3 id="fs-symlink-110">fs.symlink(linkdata, path, callback)</H3>

<P>Асинхронное создание ссылки (symlink(2)). Передаваемой функции не передаётся ничего кроме возможного исключения.</P>

<H3 id="fs-symlinksync-111">fs.symlinkSync(linkdata, path)</H3>

<P>Синхронный symlink(2).</P>

<H3 id="fs-readlink-112">fs.readlink(path, callback)</H3>

<P>Асинхронное разрешение ссылки (readlink(2)). Обработчик принимает два аргумента <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> resolvedPath<SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<H3 id="fs-readlinksync-113">fs.readlinkSync(path)</H3>

<P>Синхронный readlink(2). Возвращает полученный путь.</P>

<H3 id="fs-realpath-114">fs.realpath(path, callback)</H3>

<P>Асинхронный realpath(2).  Обработчик принимает два аргумента <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> resolvedPath<SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<H3 id="fs-realpathsync-115">fs.realpathSync(path)</H3>

<P>Синхронный realpath(2). Возвращает полученный путь.</P>

<H3 id="fs-unlink-116">fs.unlink(path, callback)</H3>

<P>Асинхронный unlink(2). Передаваемой функции не передаётся ничего кроме возможного исключения.</P>

<H3 id="fs-unlinksync-117">fs.unlinkSync(path)</H3>

<P>Синхронный unlink(2).</P>

<H3 id="fs-rmdir-118">fs.rmdir(path, callback)</H3>

<P>Асинхронный rmdir(2). Передаваемой функции не передаётся ничего кроме возможного исключения.</P>

<H3 id="fs-rmdirsync-119">fs.rmdirSync(path)</H3>

<P>Синхронный rmdir(2).</P>

<H3 id="fs-mkdir-120">fs.mkdir(path, mode, callback)</H3>

<P>Асинхронное создание директории (mkdir(2)). Передаваемой функции не передаётся ничего кроме возможного исключения.</P>

<H3 id="fs-mkdirsync-121">fs.mkdirSync(path, mode)</H3>

<P>Синхронный mkdir(2).</P>

<H3 id="fs-readdir-122">fs.readdir(path, callback)</H3>

<P>Асинхронное чтение содержимого директории (readdir(3)).
Обработчик принимает два аргумента <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> files<SPAN class="sh_symbol">)</SPAN></CODE> где <CODE class="sh_sourceCode">files</CODE> это массив имён файлов в директории исключая <CODE class="sh_sourceCode"><SPAN class="sh_string">'.'</SPAN></CODE> и <CODE class="sh_sourceCode"><SPAN class="sh_string">'..'</SPAN></CODE>.</P>

<H3 id="fs-readdirsync-123">fs.readdirSync(path)</H3>

<P>Синхронный readdir(3). Возвращает массив имён файлов исключая <CODE class="sh_sourceCode"><SPAN class="sh_string">'.'</SPAN></CODE> и <CODE class="sh_sourceCode"><SPAN class="sh_string">'..'</SPAN></CODE>.</P>

<H3 id="fs-close-124">fs.close(fd, callback)</H3>

<P>Асинхронный close(2). Передаваемой функции не передаётся ничего кроме возможного исключения.</P>

<H3 id="fs-closesync-125">fs.closeSync(fd)</H3>

<P>Синхронный close(2).</P>

<H3 id="fs-open-126">fs.open(path, flags, mode, callback)</H3>

<P>Асинхронное открытие файла. См. open(2). Флаги могут быть 'r', 'r+', 'w', 'w+', 'a',
или 'a+'. Обработчик принимает два аргумента <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> fd<SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<H3 id="fs-opensync-127">fs.openSync(path, flags, mode)</H3>

<P>Синхронное открытие файла (open(2)).</P>

<H3 id="fs-write-128">fs.write(fd, buffer, offset, length, position, callback)</H3>

<P>Записывает буфер <CODE class="sh_sourceCode">buffer</CODE> в файл указанный дескриптором <CODE class="sh_sourceCode">fd</CODE>.</P>

<P>Сдвиг <CODE class="sh_sourceCode">offset</CODE> и длина <CODE class="sh_sourceCode">length</CODE> определяют часть буфера, которая будет записана.</P>

<P>Позиция <CODE class="sh_sourceCode">position</CODE> задаёт смещение от начала файла куда должны быть записаны данные. Если <CODE class="sh_sourceCode">position</CODE> равна <CODE class="sh_sourceCode"><SPAN class="sh_keyword">null</SPAN></CODE>, данные записываются с текущей позиции.
См. pwrite(2).</P>

<P>Обработчик принимает два аргумента <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> written<SPAN class="sh_symbol">)</SPAN></CODE> где <CODE class="sh_sourceCode">written</CODE>
указывает сколько <EM>байт</EM> было записано в файл.</P>

<H3 id="fs-writesync-129">fs.writeSync(fd, data, position, encoding)</H3>

<P>Синхронная версия <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>. Возвращает число записанных байт.</P>

<H3 id="fs-read-130">fs.read(fd, buffer, offset, length, position, callback)</H3>

<P>читает данные из файла, указанного дескриптором <CODE class="sh_sourceCode">fd</CODE>.</P>

<P><CODE class="sh_sourceCode">buffer</CODE> это буфер, в который будут помещены прочитанные данные.</P>

<P><CODE class="sh_sourceCode">offset</CODE> это смещение внутри буфера с которого начнётся запись.</P>

<P><CODE class="sh_sourceCode">length</CODE> это число байт для чтения.</P>

<P><CODE class="sh_sourceCode">position</CODE> это число означающее позицию, с которой начнётся чтение файла.
Если <CODE class="sh_sourceCode">position</CODE> принимает значение <CODE class="sh_sourceCode"><SPAN class="sh_keyword">null</SPAN></CODE>, данные будут прочитаны с текущей позиции.</P>

<P>Функция-обработчик принимает два аргумента, <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> bytesRead<SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<H3 id="fs-readsync-131">fs.readSync(fd, buffer, offset, length, position)</H3>

<P>Синхронная версия <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>read</CODE>. Возвращает количество прочитанных байт.</P>

<H3 id="fs-readfile-132">fs.readFile(filename, [encoding,] callback)</H3>

<P>Асинхронно загружает в память содержимое файла. Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">readFile</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/etc/passwd'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">throw</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Обработчику передаются два аргумента: <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> data<SPAN class="sh_symbol">)</SPAN></CODE>, где <CODE class="sh_sourceCode">data</CODE> это содержимое файла.</P>

<P>Если кодировка не указана, возвращается буфер.</P>

<H3 id="fs-readfilesync-133">fs.readFileSync(filename [, encoding])</H3>

<P>Синхронная версия <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>readFile</CODE>. Возвращает содержимое файла <CODE class="sh_sourceCode">filename</CODE>.</P>

<P>Если указана кодировка <CODE class="sh_sourceCode">encoding</CODE> функция возвращает строку. Иначе &mdash; возвращает буфер.</P>

<H3 id="fs-writefile-134">fs.writeFile(filename, data, encoding='utf8', callback)</H3>

<P>Асинхронно записывает данные в файл. Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">writeFile</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'message.txt'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'Hello Node'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">throw</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'It</SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\'</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">s saved!'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="fs-writefilesync-135">fs.writeFileSync(filename, data, encoding='utf8')</H3>

<P>Синхронная версия <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>writeFile</CODE>.</P>

<H3 id="fs-watchfile-136">fs.watchFile(filename, [options,] listener)</H3>

<P>Наблюдает за изменениями файла <CODE class="sh_sourceCode">filename</CODE>. Обработчик <CODE class="sh_sourceCode">listener</CODE> вызывается каждый раз при изменении содержимого файла.</P>

<P>Второй аргумент необязателен. Объект <CODE class="sh_sourceCode">options</CODE> если он передан должен содержать два свойства: двоичное <CODE class="sh_sourceCode">persistent</CODE>, и <CODE class="sh_sourceCode">interval</CODE>, задержку между проверками файла в миллисекундах. Значение по умолчанию: <CODE class="sh_sourceCode"><SPAN class="sh_cbracket">{</SPAN>persistent<SPAN class="sh_symbol">:</SPAN> <SPAN class="sh_keyword">true</SPAN><SPAN class="sh_symbol">,</SPAN> interval<SPAN class="sh_symbol">:</SPAN> <SPAN class="sh_number">0</SPAN><SPAN class="sh_cbracket">}</SPAN></CODE>.</P>

<P>Обработчик <CODE class="sh_sourceCode">listener</CODE> принимает два аргумента: текущий объект stat и предыдущий объект stat:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">fs<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">watchFile</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>f<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>curr<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> prev<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'the current mtime is: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> curr<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>mtime<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'the previous mtime was: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> prev<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>mtime<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Эти объекты &mdash; экземпляры <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN>Stat</CODE>.</P>

<H3 id="fs-unwatchfile-137">fs.unwatchFile(filename)</H3>

<P>Прекращает обрабатывать изменения файла <CODE class="sh_sourceCode">filename</CODE>.</P>

<H2 id="fs-stats-138">fs.Stats</H2>

<P>Объекты, возвращаемые <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">stat</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> и <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">lstat</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> являются экземплярами этого класса.</P>

<UL>
<LI><CODE class="sh_sourceCode">stats<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">isFile</SPAN><SPAN class="sh_symbol">()</SPAN></CODE></LI>
<LI><CODE class="sh_sourceCode">stats<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">isDirectory</SPAN><SPAN class="sh_symbol">()</SPAN></CODE></LI>
<LI><CODE class="sh_sourceCode">stats<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">isBlockDevice</SPAN><SPAN class="sh_symbol">()</SPAN></CODE></LI>
<LI><CODE class="sh_sourceCode">stats<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">isCharacterDevice</SPAN><SPAN class="sh_symbol">()</SPAN></CODE></LI>
<LI><CODE class="sh_sourceCode">stats<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">isSymbolicLink</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> (only valid with  <CODE class="sh_sourceCode">fs<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">lstat</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>)</LI>
<LI><CODE class="sh_sourceCode">stats<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">isFIFO</SPAN><SPAN class="sh_symbol">()</SPAN></CODE></LI>
<LI><CODE class="sh_sourceCode">stats<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">isSocket</SPAN><SPAN class="sh_symbol">()</SPAN></CODE></LI>
</UL>


<H2 id="fs-readstream-139">fs.ReadStream</H2>

<P><CODE class="sh_sourceCode">ReadStream</CODE> это поток с возможностью чтения.</P>

<H3 id="fs-createreadstream-140">fs.createReadStream(path, [options])</H3>

<P>Возвращает новый объект ReadStream.</P>

<P><CODE class="sh_sourceCode">options</CODE> это объект со следующими полями по умолчанию:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'flags'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'r'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'encoding'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'binary'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'mode'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0666</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bufferSize'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">4</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">*</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1024</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<H3 id="readstream-readable-141">readStream.readable</H3>

<P>Двоичное свойство, принимающее значение <CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE> по умолчанию, но переключаемое в <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE> после события ошибки <CODE class="sh_sourceCode"><SPAN class="sh_string">'error'</SPAN></CODE>
, закрытия потока (событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'end'</SPAN></CODE>), или вызова <CODE class="sh_sourceCode"><SPAN class="sh_function">destroy</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="readstream-pause-142">readStream.pause()</H3>

<P>Прекращает чтение данных потоком. События <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE> не будут происходить пока поток не будет разблокирован.</P>

<H3 id="readstream-resume-143">readStream.resume()</H3>

<P>Разблокирует поток. Вместе с <CODE class="sh_sourceCode"><SPAN class="sh_function">pause</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> может использоваться для контроля чтения.</P>

<H3 id="readstream-destroy-144">readStream.destroy()</H3>

<P>Позволяет закрыть поток не дожидаясь события <CODE class="sh_sourceCode"><SPAN class="sh_string">'end'</SPAN></CODE>. Никакие события кроме <CODE class="sh_sourceCode"><SPAN class="sh_string">'close'</SPAN></CODE> не будут происходить после вызова этого метода.</P>

<H2 id="fs-writestream-145">fs.WriteStream</H2>

<P><CODE class="sh_sourceCode">WriteStream</CODE> это поток с возможностью записи.</P>

<H3 id="fs-createwritestream-146">fs.createWriteStream(path, [options])</H3>

<P>Возвращает новый объект WriteStream.
<CODE class="sh_sourceCode">options</CODE> это объект со следующими свойствами по умолчанию:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'flags'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'w'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'encoding'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'binary'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'mode'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0666</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<H3 id="writestream-writeable-147">writeStream.writeable</H3>

<P>Двоичное свойство, по умолчанию установленное в <CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE> , но принимающее значение <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE> после события <CODE class="sh_sourceCode"><SPAN class="sh_string">'error'</SPAN></CODE>
или вызова <CODE class="sh_sourceCode"><SPAN class="sh_function">end</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> / <CODE class="sh_sourceCode"><SPAN class="sh_function">destroy</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="writestream-write-148">writeStream.write(data, encoding='utf8')</H3>

<P>Возвращает <CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE> если данные были переданы ядру, и <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE> если они были поставлены в очередь на запись. После записи всех данных в очереди будет сгенерировано событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'drain'</SPAN></CODE>.</P>

<P>Второй необязательный параметр указывает кодировку строки.</P>

<H3 id="writestream-end-149">writeStream.end()</H3>

<P>Закрывает поток после того как все отложенные вызовы <CODE class="sh_sourceCode"><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> завершатся.</P>

<H3 id="writestream-destroy-150">writeStream.destroy()</H3>

<P>Позволяет закрыть поток независимо от его текущего состояния.</P>

<H2 id="http-151">HTTP</H2>

<P>Для использования клиента и сервера HTTP необходимо подключить соответствующий модуль с помощью <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'http'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<P>Интерфейс HTTP спроектирован в Node таким образом чтобы поддерживать
многие возможности протокола, которые традиционно было довольно сложно использовать.
В частности, большие сообщения с возможной chunk-encoding. Интерфейс никогда
не сохраняет в буфере целиком запрос или ответ, давая пользователю возможность 
принимать и отправлять данные в потоковом режиме.</P>

<P>Заголовки сообщения HTTP представлены примерно таким объектом:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'content-length'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'123'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'content-type'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'text/plain'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'stream'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'keep-alive'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'accept'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'*/*'</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<P>Ключи приводятся к нижнему регистру. Значения не изменяются.</P>

<P>Для поддержки всего спектра возможных применений HTTP, соответствующее API в
Node довольно низкоуровневое. Оно основано на потоках и передаче сообщений.
Node разбирает HTTP-сообщение на заголовки и тело, остальное должен сделать программист.</P>

<P>HTTPS поддерживается если на целевой платформе доступен OpenSSL.</P>

<H2 id="http-server-152">http.Server</H2>

<P>Это EventEmitter со следующими событиями:</P>

<H3 id="event-request-153">Событие: 'request'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>request<SPAN class="sh_symbol">,</SPAN> response<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Объект <CODE class="sh_sourceCode">request</CODE> &mdash; экземпляр <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>ServerRequest</CODE>, объект <CODE class="sh_sourceCode">response</CODE> &mdash;
 экземпляр <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>ServerResponse</CODE></P>

<H3 id="event-connection-154">Событие: 'connection'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>stream<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P> Генерируется при установке нового HTTP-соединения. <CODE class="sh_sourceCode">stream</CODE> &mdash; объект типа
 <CODE class="sh_sourceCode">net<SPAN class="sh_symbol">.</SPAN>Stream</CODE>. Обычно пользователи не используют это событие. Объект потока <CODE class="sh_sourceCode">stream</CODE> также можно найти в свойстве объекта запроса <CODE class="sh_sourceCode">request<SPAN class="sh_symbol">.</SPAN>connection</CODE>.</P>

<H3 id="event-close-155">Событие: 'close'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>errno<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P> Генерируется при завершении работы сервера.</P>

<H3 id="http-createserver-156">http.createServer(requestListener, [options])</H3>

<P>Возвращает новый объект web-сервера.</P>

<P>Аргумент <CODE class="sh_sourceCode">options</CODE> необязателен. Аргумент
<CODE class="sh_sourceCode">options</CODE> принимает те же значения, что объект параметров для
сервера <CODE class="sh_sourceCode">net<SPAN class="sh_symbol">.</SPAN>Server</CODE>.</P>

<P>Функция <CODE class="sh_sourceCode">requestListener</CODE> автоматически добавляется к событию
<CODE class="sh_sourceCode"><SPAN class="sh_string">'request'</SPAN></CODE> сервера.</P>

<H3 id="event-request-157">Событие: 'request'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>request<SPAN class="sh_symbol">,</SPAN> response<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Генерируется каждый раз при получении запроса. Заметьте, что в течении одного соединения
может происходить несколько запросов (в случае keep-alive соединения).</P>

<H3 id="event-upgrade-158">Событие: 'upgrade'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>request<SPAN class="sh_symbol">,</SPAN> socket<SPAN class="sh_symbol">,</SPAN> head<SPAN class="sh_symbol">)</SPAN></CODE></P>

<P>Генерируется каждый раз когда клиент запрашивает апгрейд соединения до защищённого (см. RFC 2817).
Если это событие никак не обрабатывается соединение для которого запрошен апгрейд будет закрыто.</P>

<UL>
<LI><CODE class="sh_sourceCode">request</CODE> &mdash; аргументы для HTTP запроса, как в событии 'request'.</LI>
<LI><CODE class="sh_sourceCode">socket</CODE> &mdash; сетевой сокет между сервером и клиентом.</LI>
<LI><CODE class="sh_sourceCode">head</CODE> &mdash; экземпляр Buffer, первый пакет защищенного потока, может быть пустым.</LI>
</UL>

<P>После генерации этого события, у объекта server не будет обработчика события <CODE class="sh_sourceCode">data</CODE>, и программисту нужно назначить его заново чтобы обрабатывать данные, получаемые этим соединением.</P>

<H3 id="event-clienterror-159">Событие: 'clientError'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>exception<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Если соединение с клиентом генерирует событие 'error' &mdash; оно поднимается сюда.</P>

<H3 id="server-listen-160">server.listen(port, hostname=null, callback=null)</H3>

<P>Начинает приём соединений на указанном порту и имени хоста. Если имя хоста не указано, сервер будет принимать соединения на любой IPv4-адрес машины (<CODE class="sh_sourceCode">INADDR_ANY</CODE>).</P>

<P>Чтобы слушать unix-сокет, передайте имя файла вместо порта и имени хоста.</P>

<P>Эта функция асинхронна. Функция, переданная последним параметром <CODE class="sh_sourceCode">callback</CODE> будет вызвана
когда сервер будет повешен на порт.</P>

<H3 id="server-listen-161">server.listen(path, callback=null)</H3>

<P>Начинает слушать unix-сокет с заданным путём <CODE class="sh_sourceCode">path</CODE>.</P>

<P>Эта функция асинхронна. Функция, переданная последним параметром <CODE class="sh_sourceCode">callback</CODE> будет вызвана
когда сервер будет повешен на порт.</P>

<H3 id="server-setsecure-162">server.setSecure(credentials)</H3>

<P>Включает поддержку HTTPS для сервера, с параметрами для криптографического модуля: private-ключом и сертификатом сервера; также можно передать CA-сертификат для аутентификации клиентов.</P>

<P>Если в параметрах указан один или несколько CA-сертификатов, сервер запросит у клиента его сертификат при установке HTTPS-соединения. Достоверность и содержимое сертификата могут быть проверены с помощью методов verifyPeer() and getPeerCertificate() объекта request.connection сервера.</P>

<H3 id="server-close-163">server.close()</H3>

<P>Прекращает приём новых соединений сервером.</P>

<H2 id="http-serverrequest-164">http.ServerRequest</H2>

<P>Этот объект создаётся автоматически HTTP-сервером (не пользователем) и передаётся первым аргументом обработчику события <CODE class="sh_sourceCode"><SPAN class="sh_string">'request'</SPAN></CODE>.</P>

<P>Это EventEmitter со следующими событиями:</P>

<H3 id="event-data-165">Событие: 'data'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>chunk<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется при получении части тела сообщения.</P>

<P>Пример: Часть тела сообщения передаётся как единственный
аргумент. Сообщение уже раскодировано из transfer-encoding. Часть тела представлена в виде строки. Кодировка тела сообщения задаётся <CODE class="sh_sourceCode">request<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">setBodyEncoding</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="event-end-166">Событие: 'end'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется строго один раз для каждого сообщения. Нет аргументов. После этого события запрос не будет генерировать другие.</P>

<H3 id="request-method-167">request.method</H3>

<P>Метод запроса в виде строки. Только для чтения. Пример:
<CODE class="sh_sourceCode"><SPAN class="sh_string">'GET'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'DELETE'</SPAN></CODE>.</P>

<H3 id="request-url-168">request.url</H3>

<P>Строка с URL запроса. Здесь содержится URL в том виде, в котором он задан в самом HTTP-запросе. Если запрос выглядит так:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_normal"><SPAN class="sh_normal">GET </SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">/</SPAN></SPAN>status<SPAN class="sh_symbol"><SPAN class="sh_symbol">?</SPAN></SPAN>name<SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN>ryan <SPAN class="sh_normal"><SPAN class="sh_normal">HTTP</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">/</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">1.1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">\</SPAN></SPAN>r<SPAN class="sh_symbol"><SPAN class="sh_symbol">\</SPAN></SPAN>n
Accept<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_normal"><SPAN class="sh_normal">text</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">/</SPAN></SPAN>plain<SPAN class="sh_symbol"><SPAN class="sh_symbol">\</SPAN></SPAN>r<SPAN class="sh_symbol"><SPAN class="sh_symbol">\</SPAN></SPAN>n
<SPAN class="sh_symbol"><SPAN class="sh_symbol">\</SPAN></SPAN>r<SPAN class="sh_symbol"><SPAN class="sh_symbol">\</SPAN></SPAN>n
</CODE></PRE>

<P>Тогда значением <CODE class="sh_sourceCode">request<SPAN class="sh_symbol">.</SPAN>url</CODE> будет:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_string"><SPAN class="sh_string">'/status?name=ryan'</SPAN></SPAN>
</CODE></PRE>

<P>Если вы хотите разделить URL на составные части, вы можете использовать <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'url'</SPAN><SPAN class="sh_symbol">).</SPAN><SPAN class="sh_function">parse</SPAN><SPAN class="sh_symbol">(</SPAN>request<SPAN class="sh_symbol">.</SPAN>url<SPAN class="sh_symbol">)</SPAN></CODE>. Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'url'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">parse</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/status?name=ryan'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> href<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'/status?name=ryan'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> search<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'?name=ryan'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> query<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'name=ryan'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> pathname<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'/status'</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<P>Если вам нужно извлечь параметры из строки запроса, можно использовать функцию
you can use the <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'querystring'</SPAN><SPAN class="sh_symbol">).</SPAN>parse</CODE> , или передать
<CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE> в качестве второго аргумента <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'url'</SPAN><SPAN class="sh_symbol">).</SPAN>parse</CODE>.  Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'url'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">parse</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/status?name=ryan'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">true</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> href<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'/status?name=ryan'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> search<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'?name=ryan'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> query<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> name<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'ryan'</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> pathname<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'/status'</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<H3 id="request-headers-169">request.headers</H3>

<P>Заголовки запроса. Только для чтения.</P>

<H3 id="request-httpversion-170">request.httpVersion</H3>

<P>Версия протокола HTTP в виде строки. Только чтение. Пример:
<CODE class="sh_sourceCode"><SPAN class="sh_string">'1.1'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'1.0'</SPAN></CODE>.
Также <CODE class="sh_sourceCode">request<SPAN class="sh_symbol">.</SPAN>httpVersionMajor</CODE> это первое число и
<CODE class="sh_sourceCode">request<SPAN class="sh_symbol">.</SPAN>httpVersionMinor</CODE> &mdash; второе.</P>

<H3 id="request-setencoding-171">request.setEncoding(encoding='binary')</H3>

<P>Задаёт кодировку тела запроса. Либо <CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE> либо <CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE>. По умолчанию принимает значение <CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE>.</P>

<H3 id="request-pause-172">request.pause()</H3>

<P>Прекращает генерирование событий запросом. Можно использовать для ускорения закачки файла.</P>

<H3 id="request-resume-173">request.resume()</H3>

<P>Возобновляет генерирование событий запросом</P>

<H3 id="request-connection-174">request.connection</H3>

<P>Объект соединения, экземпляр <CODE class="sh_sourceCode">net<SPAN class="sh_symbol">.</SPAN>Stream</CODE></P>

<P>Если включена поддержка HTTPS, используйте request.connection.verifyPeer() и
request.connection.getPeerCertificate() чтобы получить сведения об аутентификации клиента.</P>

<H2 id="http-serverresponse-175">http.ServerResponse</H2>

<P>Этот объект создаётся внутри HTTP-сервера &mdash; не пользователем. Он передаётся
вторым параметром в обработчик события <CODE class="sh_sourceCode"><SPAN class="sh_string">'request'</SPAN></CODE> и является потоком с возможностью записи.</P>

<H3 id="response-writehead-176">response.writeHead(statusCode[, reasonPhrase] , headers)</H3>

<P>Отправляет заголовки ответа клиенту. <CODE class="sh_sourceCode"><SPAN class="sh_string">statusCode</SPAN></CODE> это три цифры кода статуса HTTP, например <CODE class="sh_sourceCode"><SPAN class="sh_number">404</SPAN></CODE>. Последний аргумент, <CODE class="sh_sourceCode">headers</CODE>, это заголовки ответа.
Также вторым аргументом можно передать фразу <CODE class="sh_sourceCode">reasonPhrase</CODE> в качестве второго аргумента.</P>

<P>Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> body <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'hello world'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">writeHead</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">200</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_string"><SPAN class="sh_string">'Content-Length'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> body<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  <SPAN class="sh_string"><SPAN class="sh_string">'Content-Type'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'text/plain'</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Этот метод должен быть вызван только однажды для каждого сообщения и должен быть вызван до <CODE class="sh_sourceCode">response<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">end</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="response-write-177">response.write(chunk, encoding)</H3>

<P>Этот метод должен вызываться после <CODE class="sh_sourceCode">writeHead</CODE>. Он отправляет часть тела ответа. Метод может быть вызван несколько раз для отправки последующих частей тела ответа.</P>

<P>Если <CODE class="sh_sourceCode">chunk</CODE> это строка, второй параметр указывает в какой кодировке отправлять её в поток. По умолчанию <CODE class="sh_sourceCode">encoding</CODE> принимает значение <CODE class="sh_sourceCode"><SPAN class="sh_string">'ascii'</SPAN></CODE>.</P>

<P><STRONG>Замечание</STRONG>: Это необработанное тело HTTP-ответа и не имеет отношения к более высокоуровневым вещам вроде multi-part encoding, которые тоже могут использоваться.</P>

<P>После первого вызова <CODE class="sh_sourceCode">response<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> клиенту будет отправлены заголовки и первая часть тела сообщения. После второго вызова <CODE class="sh_sourceCode">response<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> Node предполагает что вы начинаете потоковую передачу данных и отправляет часть тела отдельно. Таким образом, данные буферизуются только до первой части тела ответа.</P>

<H3 id="response-end-178">response.end()</H3>

<P>Этот метод отправляет серверу сигнал что все заголовки и тело ответа отправлены; сервер должен считать это сообщение законченным.
Метод <CODE class="sh_sourceCode">response<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">end</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> ДОЛЖЕН быть вызван при каждом ответе.</P>

<H2 id="http-client-179">http.Client</H2>

<P>HTTP-клиент создаётся принимая адрес сервера в качестве аргумента,
возвращаемый идентификатор используется для отправки одного или нескольких запросов. В зависимости от того, к какому серверу совершено подключение клиент может использовать pipeline (несколько запросов за соединение) либо пересоздавать поток после каждого запроса. <em>Текущая версия не использует pipeline</em>.</P>

<P>Пример подключения к <CODE class="sh_sourceCode">google<SPAN class="sh_symbol">.</SPAN>com</CODE>:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> http <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'http'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> google <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> http<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">createClient</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">80</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'www.google.com'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> request <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> google<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">request</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'GET'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'/'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'host'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'www.google.com'</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
request<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">end</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>
request<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'response'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>response<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'STATUS: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>statusCode<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'HEADERS: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> JSON<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>headers<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
  response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">setEncoding</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'utf8'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>chunk<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'BODY: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> chunk<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="event-upgrade-180">Событие: 'upgrade'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>request<SPAN class="sh_symbol">,</SPAN> socket<SPAN class="sh_symbol">,</SPAN> head<SPAN class="sh_symbol">)</SPAN></CODE></P>

<P>Генерируется каждый раз когда сервер отвечает на запрос предложением улучшить соединение до безопасного. Если это событие не обрабатывается, клиент при получении заголовка upgrade будет закрывать соединение.</P>

<P>См. описание события <CODE class="sh_sourceCode">upgrade</CODE> для <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>Server</CODE>.</P>

<H3 id="http-createclient-181">http.createClient(port, host, secure, credentials)</H3>

<P>Создаёт новый HTTP клиент. <CODE class="sh_sourceCode">port</CODE> и
<CODE class="sh_sourceCode">host</CODE> относятся к серверу, к которому производится подключение. Поток не создаётся до отправки запроса.</P>

<P><CODE class="sh_sourceCode">secure</CODE> &mdash; дополнительный двоичный флаг для включения поддержки https и <CODE class="sh_sourceCode">credentials</CODE> &mdash; необязательный объект параметров для crypto-модуля, хранящий private-ключ клиента, сертификат и список доверенных CA сертификатов.</P>

<P>Если соединение зашифровано но в объекте параметров не переданы сертификаты CA, node.js будет использовать публично доступный список CA, как он представлен в http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</P>

<H3 id="client-request-182">client.request([method], path, [request_headers])</H3>

<P>Отправляет запрос; при необходимости инициирует соединение. Возвращает экземпляр <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>ClientRequest</CODE>.</P>

<P><CODE class="sh_sourceCode">method</CODE> &mdash; необязательный параметр, по умолчанию принимает значение 'GET'.</P>

<P><CODE class="sh_sourceCode">request_headers</CODE> необязательный параметр.
Дополнительные заголовки запроса могут быть добавлены внутри Node. Возвращает объект <CODE class="sh_sourceCode">ClientRequest</CODE>.</P>

<P>Не забудьте включить заголовок <CODE class="sh_sourceCode">Content<SPAN class="sh_symbol">-</SPAN>Length</CODE> если планируете отправить тело запроса. Если вы хотите отправить тело запроса потоком, поставьте <CODE class="sh_sourceCode">Transfer<SPAN class="sh_symbol">-</SPAN>Encoding<SPAN class="sh_symbol">:</SPAN> chunked</CODE>.</P>

<P><EM>ВНМАНИЕ</EM>: запрос ещё не закончен. Этот метод только отсылает заголовки серверу. Необходимо вызвать <CODE class="sh_sourceCode">request<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">end</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> чтобы отправить запрос целиком и получить ответ.  (Это звучит сложно, но позволяет пользователю передавать тело запроса в потоковом режиме с помощью <CODE class="sh_sourceCode">request<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.)</P>

<H3 id="client-verifypeer-183">client.verifyPeer()</H3>

<P>Возвращает true или false в зависимости от подлинности сертификата сервера соответственно списку доверенных сертификатов CA (переданному явно или используемому по умолчанию).</P>

<H3 id="client-getpeercertificate-184">client.getPeerCertificate()</H3>

<P>Возвращает JSON с деталями сертификата сервера, содержит поля 'subject', 'issuer', 'valid_from' и 'valid_to'</P>

<H2 id="http-clientrequest-185">http.ClientRequest</H2>

<P>Объект создаётся внутри Node и возвращается методом <CODE class="sh_sourceCode"><SPAN class="sh_function">request</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>
объекта <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>Client</CODE>. Он представляет собой <EM>незаконченный</EM> запрос, заголовки которого уже отправлены.</P>

<P>Чтобы получить ответ, добавьте обработчик событию <CODE class="sh_sourceCode"><SPAN class="sh_string">'response'</SPAN></CODE> объекта запроса.
Событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'response'</SPAN></CODE> будет сгенерировано объектом запроса при получении заголовков ответа. Обработчик события <CODE class="sh_sourceCode"><SPAN class="sh_string">'response'</SPAN></CODE> выполняется с одним аргументом &mdash; экземпляром <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>ClientResponse</CODE>.</P>

<P>Во время события <CODE class="sh_sourceCode"><SPAN class="sh_string">'response'</SPAN></CODE> можно добавлять обработчики к объекту ответа; в частности, чтобы получать части тела ответа надо добавить обработчик событию <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE>. Заметьте что обработчик события <CODE class="sh_sourceCode"><SPAN class="sh_string">'response'</SPAN></CODE> вызывается до того как будут получены части тела ответа, поэтому не надо беспокоиться что первая часть тела будет пропущена.
Если обработчик <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE> добавляется во время события <CODE class="sh_sourceCode"><SPAN class="sh_string">'response'</SPAN></CODE> всё тело ответа будет получено наверняка.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_comment"><SPAN class="sh_comment">// Good</SPAN></SPAN>
request<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'response'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>response<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>chunk<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'BODY: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> chunk<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

<SPAN class="sh_comment"><SPAN class="sh_comment">// Bad - misses all or part of the body</SPAN></SPAN>
request<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'response'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>response<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_function"><SPAN class="sh_function">setTimeout</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    response<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>chunk<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
      console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'BODY: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> chunk<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
    <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">10</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Это поток с возможностью записи.</P>

<P>Это экземпляр <CODE class="sh_sourceCode">EventEmitter</CODE> со следующими событиями:</P>

<H3 id="event-response-186">Событие: 'response'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>response<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда на запрос приходит ответ. Это событие генерируется только один раз. Аргументом обработчика
<CODE class="sh_sourceCode">response</CODE> будет экземпляр <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>ClientResponse</CODE>.</P>

<H3 id="request-write-187">request.write(chunk, encoding='ascii')</H3>

<P>Отправляет часть тела запроса. Вызывая этот метод несколько раз, пользователь может отправлять тело ответа серверу в потоковом режиме &mdash; в таком случае предпочтительно добавлять в заголовки <CODE class="sh_sourceCode"><SPAN class="sh_symbol">[</SPAN><SPAN class="sh_string">'Transfer-Encoding'</SPAN><SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_string">'chunked'</SPAN><SPAN class="sh_symbol">]</SPAN></CODE> при создании запроса.</P>

<P>Аргумент <CODE class="sh_sourceCode">chunk</CODE> должен быть массивом чисел или строкой.</P>

<P>Аргумент <CODE class="sh_sourceCode">encoding</CODE> необязателен и имеет значение только если <CODE class="sh_sourceCode">chunk</CODE> это строка. Аргумент encoding должен принимать значение <CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE> или
<CODE class="sh_sourceCode"><SPAN class="sh_string">'ascii'</SPAN></CODE>. По умолчанию используется кодировка ASCII как более быстрая для обработки.</P>

<H3 id="request-end-188">request.end()</H3>

<P>Завершает отправку запроса. Если какие то части тела запроса ещё не были отправлены, они отправляются. Если запрос разбит на части, будет послана завершающая последовательность <CODE class="sh_sourceCode"><SPAN class="sh_string">'0</SPAN><SPAN class="sh_specialchar">\r\n\r\n</SPAN><SPAN class="sh_string">'</SPAN></CODE>.</P>

<H2 id="http-clientresponse-189">http.ClientResponse</H2>

<P>Этот объект создаётся при создании запроса с помощью <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>Client</CODE>. Он передаётся обработчику события <CODE class="sh_sourceCode"><SPAN class="sh_string">'response'</SPAN></CODE> объекта запроса.</P>

<P>Объект ответа &mdash; поток с возможностью чтения.</P>

<H3 id="event-data-190">Событие: 'data'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>chunk<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Генерирется при получении части тела сообщения.</P>

<P>Часть тела сообщения передаётся обработчику в качестве единственного аргумета. Строка уже преобразована из кодировки с помощью которой осуществлялась передача. Часть тела сообщения передаётся обработчику в виде строки. Кодировка тела сообщения задаётся response.setBodyEncoding().</P>

<H3 id="event-end-191">Событие: 'end'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Генерируется только однажды для каждого сообщения. Обработчик вызывается без аргументов. После этого сообщение не будет генерировать никаких событий.</P>

<H3 id="response-statuscode-192">response.statusCode</H3>

<P>Код статуса HTTP из трёх цифр, например <CODE class="sh_sourceCode"><SPAN class="sh_number">404</SPAN></CODE>.</P>

<H3 id="response-httpversion-193">response.httpVersion</H3>

<P>Версия HTTP для текущего соединения. Скорее всего либо 
<CODE class="sh_sourceCode"><SPAN class="sh_string">'1.1'</SPAN></CODE> либо <CODE class="sh_sourceCode"><SPAN class="sh_string">'1.0'</SPAN></CODE>.
Также <CODE class="sh_sourceCode">response<SPAN class="sh_symbol">.</SPAN>httpVersionMajor</CODE> &mdash; первая цифра версии,
<CODE class="sh_sourceCode">response<SPAN class="sh_symbol">.</SPAN>httpVersionMinor</CODE> &mdash; вторая.</P>

<H3 id="response-headers-194">response.headers</H3>

<P>Заголовки ответа.</P>

<H3 id="response-setencoding-195">response.setEncoding(encoding)</H3>

<P>Задаёт кодировку тела ответа. Может принимать значения <CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE> либо <CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE>.
По умолчанию используется <CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE>.</P>

<H3 id="response-pause-196">response.pause()</H3>

<P>Приостанавливает генерацию событий ответом. Можно использовать для ускорения закачки файла.</P>

<H3 id="response-resume-197">response.resume()</H3>

<P>Возобновляет генерацию событий ответом.</P>

<H3 id="response-client-198">response.client</H3>

<P>Ссылка на <CODE class="sh_sourceCode">http<SPAN class="sh_symbol">.</SPAN>Client</CODE> которому принадлежит ответ.</P>

<H2 id="net-server-199">net.Server</H2>

<P>Этот класс используется для создания TCP или UNIX сервера.</P>

<P>Вот простой пример сервера, который возвращает полученный запрос и слушает на порту 8124:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> net <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'net'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> server <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> net<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">createServer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">setEncoding</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'utf8'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'connect'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'hello</SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\r\n</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'data'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>data<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">addListener</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'end'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">()</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">write</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'goodbye</SPAN></SPAN><SPAN class="sh_specialchar"><SPAN class="sh_specialchar">\r\n</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
    stream<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">end</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">();</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
server<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">listen</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">8124</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'localhost'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Чтобы слушать сокет <CODE class="sh_sourceCode"><SPAN class="sh_string">'/tmp/echo.sock'</SPAN></CODE>, последнюю линию надо заменить на</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">server<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">listen</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/tmp/echo.sock'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Это EventEmitter со следующими событиями:</P>

<H3 id="event-connection-200">Событие: 'connection'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>stream<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Генерируется при новом соединении. <CODE class="sh_sourceCode">stream</CODE> &mdash; экземпляр
<CODE class="sh_sourceCode">net<SPAN class="sh_symbol">.</SPAN>Stream</CODE>.</P>

<H3 id="event-close-201">Событие: 'close'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{}</SPAN></CODE></P>

<P>Генерируется при завершении работы сервера.</P>

<H3 id="net-createserver-202">net.createServer(connectionListener)</H3>

<P>Создаёт новый TCP сервер. Аргумент <CODE class="sh_sourceCode">connection_listener</CODE> автоматически становится обработчиком события <CODE class="sh_sourceCode"><SPAN class="sh_string">'connection'</SPAN></CODE>.</P>

<H3 id="server-listen-203">server.listen(port, host=null, callback=null)</H3>

<P>Начинает принимать соединения на указанном порту <CODE class="sh_sourceCode">port</CODE> и имени хоста <CODE class="sh_sourceCode">host</CODE>.  Если <CODE class="sh_sourceCode">host</CODE> пропущен, сервер будет принимать соединения на каждом IPv4-адресе (<CODE class="sh_sourceCode">INADDR_ANY</CODE>).</P>

<P>Эта функция асинхронна. Последний параметр <CODE class="sh_sourceCode">callback</CODE> будет вызван когда сервер начнёт принимать соединения.</P>

<H3 id="server-listen-204">server.listen(path, callback=null)</H3>

<P>Запускает сервер слушающий UNIX-сокет по указанному адресу <CODE class="sh_sourceCode">path</CODE>.</P>

<P>Эта функция асинхронна. Последний параметр <CODE class="sh_sourceCode">callback</CODE> будет вызван когда сервер начнёт принимать соединения.</P>

<H3 id="server-listenfd-205">server.listenFD(fd)</H3>

<P>Запускает сервер, слушающий указанный файловый дескриптор.</P>

<P>Для указанного файлового дескриптора должны быть уже выполнены системные вызовы <CODE class="sh_sourceCode"><SPAN class="sh_function">bind</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_number">2</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> и <CODE class="sh_sourceCode"><SPAN class="sh_function">listen</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_number">2</SPAN><SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<H3 id="server-close-206">server.close()</H3>

<P>Прекращает приём соединений сервером. Эта функция асинхронна, сервер полностью закрывается только после генерации события <CODE class="sh_sourceCode"><SPAN class="sh_string">'close'</SPAN></CODE>.</P>

<H2 id="net-stream-207">net.Stream</H2>

<P>Этот объект &mdash; абстракция TCP порта или UNIX сокета. Экземпляр <CODE class="sh_sourceCode">net<SPAN class="sh_symbol">.</SPAN>Stream</CODE>
имеет возможность как чтения, так и записи. Он может быть создан и использован как клиентом (с помощью <CODE class="sh_sourceCode"><SPAN class="sh_function">connect</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>) либо создан внутри Node
и передан пользователю через обработчик события <CODE class="sh_sourceCode"><SPAN class="sh_string">'connection'</SPAN></CODE>.</P>

<P>Экземпляры <CODE class="sh_sourceCode">net<SPAN class="sh_symbol">.</SPAN>Stream</CODE> это EventEmitter'ы со следующими событиями:</P>

<H3 id="event-connect-208">Событие: 'connect'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется после успешной установки соединения. См. <CODE class="sh_sourceCode"><SPAN class="sh_function">connect</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="event-secure-209">Событие: 'secure'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда соединение успешно проходит HTTPS-аутентификацию клиента.</P>

<H3 id="event-data-210">Событие: 'data'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>data<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется при приёме данных.  Аргумент <CODE class="sh_sourceCode">data</CODE> будет экземпляром <CODE class="sh_sourceCode">Buffer</CODE> или
<CODE class="sh_sourceCode"><SPAN class="sh_predef_func">String</SPAN></CODE>.  Кодировка передаваемых данных устанавливается методом <CODE class="sh_sourceCode">stream<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">setEncoding</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>. (См. секцию о потоках с возможностью чтения для более подробной информации.)</P>

<H3 id="event-end-211">Событие: 'end'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда другой участник соединения посылает пакет FIN. После генерации этого события свойство <CODE class="sh_sourceCode">readyState</CODE> будет установлено в значение <CODE class="sh_sourceCode"><SPAN class="sh_string">'writeOnly'</SPAN></CODE>. Часто в обработчике этого события следует просто вызвать <CODE class="sh_sourceCode">stream<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">end</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> (послав ответный FIN).</P>

<H3 id="event-timeout-212">Событие: 'timeout'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется если поток долгое время не используется. Это просто уведомление о длительной неактивности потока. Пользователь должен сам закрыть соединение.</P>

<P>См. также: <CODE class="sh_sourceCode">stream<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">setTimeout</SPAN><SPAN class="sh_symbol">()</SPAN></CODE></P>

<H3 id="event-drain-213">Событие: 'drain'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда буфер записи становится пустым (все данные, переданные в поток, были отправлены получателю). Может быть использоваться для отправки файлов.</P>

<H3 id="event-error-214">Событие: 'error'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">(</SPAN>exception<SPAN class="sh_symbol">)</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется при возникновении ошибки. Сразу после этого будет сгенерировано событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'close'</SPAN></CODE> .</P>

<H3 id="event-close-215">Событие: 'close'</H3>

<P><CODE class="sh_sourceCode"><SPAN class="sh_keyword">function</SPAN> <SPAN class="sh_symbol">()</SPAN> <SPAN class="sh_cbracket">{</SPAN> <SPAN class="sh_cbracket">}</SPAN></CODE></P>

<P>Генерируется когда поток полностью закрывается. Аргумент <CODE class="sh_sourceCode">had_error</CODE> &mdash; двоичное значение, устанавливаемое в true если поток был закрыт из за ошибки передачи.</P>

<H3 id="net-createconnection-216">net.createConnection(port, host='127.0.0.1')</H3>

<P>Создаёт новый объект потока и открывает соединение с указанным портом <CODE class="sh_sourceCode">port</CODE>
и адресом <CODE class="sh_sourceCode">host</CODE>. Если второй параметр не задан, предполагается значение localhost.</P>

<P>Когда соединение установлено, будет сгенерировано событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'connect'</SPAN></CODE>.</P>

<H3 id="stream-connect-217">stream.connect(port, host='127.0.0.1')</H3>

<P>Открывает соединение с указанным портом <CODE class="sh_sourceCode">port</CODE> и адресом <CODE class="sh_sourceCode">host</CODE>. <CODE class="sh_sourceCode"><SPAN class="sh_function">createConnection</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>
также открывает поток; обычно этот метод не нужен. Используйте его только если поток закрыт и вы хотите повторно использовать тот же объект для соединения с другим сервером.</P>

<P>Эта функция асинхронна. Когда генерируется событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'connect'</SPAN></CODE>, соединение установлено. Если при соединении возникли проблемы, событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'connect'</SPAN></CODE>
не будет сгенерировано, вместо него будет сгенерировано событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'error'</SPAN></CODE> с аргументом исключения.</P>

<H3 id="stream-remoteaddress-218">stream.remoteAddress</H3>

<P>Строка с IP-адресом удалённой машины. Например,
<CODE class="sh_sourceCode"><SPAN class="sh_string">'74.125.127.100'</SPAN></CODE> или <CODE class="sh_sourceCode"><SPAN class="sh_string">'2001:4860:a005::68'</SPAN></CODE>.</P>

<P>Это свойство есть только у соединений сервера.</P>

<H3 id="stream-readystate-219">stream.readyState</H3>

<P>Состояние потока: <CODE class="sh_sourceCode"><SPAN class="sh_string">'closed'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'open'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'opening'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'readOnly'</SPAN></CODE>, или <CODE class="sh_sourceCode"><SPAN class="sh_string">'writeOnly'</SPAN></CODE>.</P>

<H3 id="stream-setencoding-220">stream.setEncoding(encoding)</H3>

<P>Задаёт кодировку (<CODE class="sh_sourceCode"><SPAN class="sh_string">'ascii'</SPAN></CODE>, <CODE class="sh_sourceCode"><SPAN class="sh_string">'utf8'</SPAN></CODE> или <CODE class="sh_sourceCode"><SPAN class="sh_string">'binary'</SPAN></CODE>) для принимаемых данных.</P>

<H3 id="stream-setsecure-221">stream.setSecure(credentials)</H3>

<P>Включает поддержку HTTPS для потока, параметры передаются криптографическому модулю и включают private key и сертификат потока, дополнительно могут включать сертификаты CA для аутентификации участника соединения.</P>

<P>Если объект параметров содержит один или несколько сертификатов CA, поток запросит у участника соединения сертификат в ходе установки HTTPS-соединения. Правильность и содержимое сертификата могут быть проверены функциями verifyPeer() и getPeerCertificate().</P>

<H3 id="stream-verifypeer-222">stream.verifyPeer()</H3>

<P>Возвращает true или false в зависимости от правильности сертификата участника соединения в контексте заданных CA-сертификатов (или списка CA по умолчанию).</P>

<H3 id="stream-getpeercertificate-223">stream.getPeerCertificate()</H3>

<P>Возвращает JSON с деталями сертификата участника соединения, содержащий свойства 'subject', 'issuer', 'valid_from' и 'valid_to'</P>

<H3 id="stream-write-224">stream.write(data, encoding='ascii')</H3>

<P>Отправляет данные в поток. Второй параметр означает кодировку если первым параметром передана строка --по умолчанию используется ASCII т.к. кодирование в UTF8 довольно медленно.</P>

<P>Возвращает <CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE> если все данные были успешно переданы в буфер ядра. Возвращает <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE> все данные или их часть были помещены в очередь в памяти. Событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'drain'</SPAN></CODE> будет сгенерировано когда буфер ядра снова будет пуст.</P>

<H3 id="stream-end-225">stream.end()</H3>

<P>Наполовину закрывает соединение, т.е. отправляет пакет FIN. Возможно сервер ещё получит какие-то данные. После вызова этого метода свойство <CODE class="sh_sourceCode">readyState</CODE> будет установлено в значение <CODE class="sh_sourceCode"><SPAN class="sh_string">'readOnly'</SPAN></CODE>.</P>

<H3 id="stream-destroy-226">stream.destroy()</H3>

<P>Закрывает поток таким образом чтобы в нём больше не происходило ввода-вывода. Необходимо только для закрытия соединения в случае серьёзных ошибок.</P>

<H3 id="stream-pause-227">stream.pause()</H3>

<P>Приостанавливает чтение данных. Т.е. события <CODE class="sh_sourceCode"><SPAN class="sh_string">'data'</SPAN></CODE> не будут генерироваться. Используется при приёме файлов.</P>

<H3 id="stream-resume-228">stream.resume()</H3>

<P>Возобновляет чтение данных после вызова <CODE class="sh_sourceCode"><SPAN class="sh_function">pause</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="stream-settimeout-229">stream.setTimeout(timeout)</H3>

<P>Устанавливает таймаут в <CODE class="sh_sourceCode">timeout</CODE> миллисекунд бездействия потока. По умолчанию <CODE class="sh_sourceCode">net<SPAN class="sh_symbol">.</SPAN>Stream</CODE> не имеет таймаута.</P>

<P>Если поток не будет проявлять активности указанное количество миллисекунд будет сгенерировано событие <CODE class="sh_sourceCode"><SPAN class="sh_string">'timeout'</SPAN></CODE> но само соединение не будет затронуто. пользователь должен самостоятельно вызвать <CODE class="sh_sourceCode"><SPAN class="sh_function">end</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>
или <CODE class="sh_sourceCode"><SPAN class="sh_function">destroy</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> для закрытия потока.</P>

<P>Если в качестве <CODE class="sh_sourceCode">timeout</CODE> передан 0, существующий таймаут перестаёт действовать.</P>

<H3 id="stream-setnodelay-230">stream.setNoDelay(noDelay=true)</H3>

<P>Выключает алгоритм Нагла. По умолчанию TCP-соединения используют алгоритм Нагла, собирая данные в буфер перед отправкой. Установка <CODE class="sh_sourceCode">noDelay</CODE> приведёт к немедленной отправке всех данных, передаваемых в <CODE class="sh_sourceCode">stream<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">write</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<H3 id="stream-setkeepalive-231">stream.setKeepAlive(enable=false, initialDelay)</H3>

<P>Включает/выключает функционал keep-alive , и дополнительно позволяет установить начальную задержку после которой будет отправлен первый пакет проверки соединения при неактивности.
Значение <CODE class="sh_sourceCode">initialDelay</CODE> (в миллисекундах) означает интервал между последним отправленным пакетом и первой проверкой соединения. Установка initialDelay в 0 оставит в силе предыдущее значение.</P>

<H2 id="crypto-232">Криптографический модуль</H2>

<P>Используйте <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'crypto'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> чтобы получить доступ к функциям модуля.</P>

<P>Криптографический модуль требует для своей работы наличия OpenSSL. Он предоставляет возможность использовать аутентификацию в HTTPS и HTTP-соединениях.</P>

<P>Модуль также предоставляет набор врапперов для некоторых методов OpenSSL: hash, hmac, cipher, decipher, sign и verify.</P>

<H3 id="crypto-createcredentials-233">crypto.createCredentials(details)</H3>

<P>Создаёт объект данных аутентификации, может принимать параметром объект со следующими свойствами:</P>

<P><CODE class="sh_sourceCode">key</CODE> : строка с PEM-закодированным приватным ключом</P>

<P><CODE class="sh_sourceCode">cert</CODE> : строка с PEM-закодированным сертификатом</P>

<P><CODE class="sh_sourceCode">ca</CODE> : строка или список строк PEM-закодированных доверенных корневых сертификатов.</P>

<P>Если корневые сертификаты не указаны, node.js будет использовать список доверенных сертификатов, расположенный по адресу http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</P>

<H3 id="crypto-createhash-234">crypto.createHash(algorithm)</H3>

<P>Creates and returns a hash object, a cryptographic hash with the given algorithm which can be used to generate hash digests.</P>

<P><CODE class="sh_sourceCode">algorithm</CODE> is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are sha1, md5, sha256, sha512, etc. On recent releases, <CODE class="sh_sourceCode">openssl list<SPAN class="sh_symbol">-</SPAN>message<SPAN class="sh_symbol">-</SPAN>digest<SPAN class="sh_symbol">-</SPAN>algorithms</CODE> will display the available digest algorithms.</P>

<H3 id="hash-update-235">hash.update(data)</H3>

<P>Updates the hash content with the given <CODE class="sh_sourceCode">data</CODE>. This can be called many times with new data as it is streamed.</P>

<H3 id="hash-digest-236">hash.digest(encoding)</H3>

<P>Calculates the digest of all of the passed data to be hashed. The <CODE class="sh_sourceCode">encoding</CODE> can be 'hex', 'binary' or 'base64'.</P>

<H3 id="crypto-createhmac-237">crypto.createHmac(algorithm, key)</H3>

<P>Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key.</P>

<P><CODE class="sh_sourceCode">algorithm</CODE> is dependent on the available algorithms supported by OpenSSL - see createHash above.
<CODE class="sh_sourceCode">key</CODE> is the hmac key to be used.</P>

<H3 id="hmac-update-238">hmac.update(data)</H3>

<P>Update the hmac content with the given <CODE class="sh_sourceCode">data</CODE>. This can be called many times with new data as it is streamed.</P>

<H3 id="hmac-digest-239">hmac.digest(encoding)</H3>

<P>Calculates the digest of all of the passed data to the hmac. The <CODE class="sh_sourceCode">encoding</CODE> can be 'hex', 'binary' or 'base64'.</P>

<H3 id="crypto-createcipher-240">crypto.createCipher(algorithm, key)</H3>

<P>Creates and returns a cipher object, with the given algorithm and key.</P>

<P><CODE class="sh_sourceCode">algorithm</CODE> is dependent on OpenSSL, examples are aes192, etc. On recent releases, <CODE class="sh_sourceCode">openssl list<SPAN class="sh_symbol">-</SPAN>cipher<SPAN class="sh_symbol">-</SPAN>algorithms</CODE> will display the available cipher algorithms.</P>

<H3 id="cipher-update-241">cipher.update(data, input_encoding, output_encoding)</H3>

<P>Updates the cipher with <CODE class="sh_sourceCode">data</CODE>, the encoding of which is given in <CODE class="sh_sourceCode">input_encoding</CODE> and can be 'utf8', 'ascii' or 'binary'. The <CODE class="sh_sourceCode">output_encoding</CODE> specifies the output format of the enciphered data, and can be 'binary', 'base64'  or 'hex'.</P>

<P>Returns the enciphered contents, and can be called many times with new data as it is streamed.</P>

<H3 id="cipher-final-242">cipher.final(output_encoding)</H3>

<P>Returns any remaining enciphered contents, with <CODE class="sh_sourceCode">output_encoding</CODE> as update above.</P>

<H3 id="crypto-createdecipher-243">crypto.createDecipher(algorithm, key)</H3>

<P>Creates and returns a decipher object, with the given algorithm and key. This is the mirror of the cipher object above.</P>

<H3 id="decipher-update-244">decipher.update(data, input_encoding, output_encoding)</H3>

<P>Updates the decipher with <CODE class="sh_sourceCode">data</CODE>, which is encoded in 'binary', 'base64' or 'hex'. The <CODE class="sh_sourceCode">output_decoding</CODE> specifies in what format to return the deciphered plaintext - either 'binary', 'ascii' or 'utf8'.</P>

<H3 id="decipher-final-245">decipher.final(output_encoding)</H3>

<P>Returns any remaining plaintext which is deciphered, with `output_encoding' as update above.</P>

<H3 id="crypto-createsign-246">crypto.createSign(algorithm)</H3>

<P>Creates and returns a signing object, with the given algorithm. On recent OpenSSL releases, <CODE class="sh_sourceCode">openssl list<SPAN class="sh_symbol">-</SPAN><SPAN class="sh_keyword">public</SPAN><SPAN class="sh_symbol">-</SPAN>key<SPAN class="sh_symbol">-</SPAN>algorithms</CODE> will display the available signing algorithms. Examples are 'RSA-SHA256'.</P>

<H3 id="signer-update-247">signer.update(data)</H3>

<P>Updates the signer object with data. This can be called many times with new data as it is streamed.</P>

<H3 id="signer-sign-248">signer.sign(private_key, output_format)</H3>

<P>Calculates the signature on all the updated data passed through the signer. <CODE class="sh_sourceCode">private_key</CODE> is a string containing the PEM encoded private key for signing.</P>

<P>Returns the signature in <CODE class="sh_sourceCode">output_format</CODE> which can be 'binary', 'hex' or 'base64'</P>

<H3 id="crypto-createverify-249">crypto.createVerify(algorithm)</H3>

<P>Creates and returns a verification object, with the given algorithm. This is the mirror of the signing object above.</P>

<H3 id="verifier-update-250">verifier.update(data)</H3>

<P>Updates the verifyer object with data. This can be called many times with new data as it is streamed.</P>

<H3 id="verifier-verify-251">verifier.verify(public_key, signature, signature_format)</H3>

<P>Verifies the signed data by using the <CODE class="sh_sourceCode">public_key</CODE> which is a string containing the PEM encoded public key, and <CODE class="sh_sourceCode">signature</CODE>, which is the previously calculates signature for the data, in the <CODE class="sh_sourceCode">signature_format</CODE> which can be 'binary', 'hex' or 'base64'.</P>

<P>Возвращает true или false в зависимости от действительности подписи и публичного ключа.</P>

<H2 id="dns-252">DNS</H2>

<P>Используйте <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'dns'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> чтобы получить доступ к модулю.</P>

<P>Пример, преобразующий в IP-адрес хост <CODE class="sh_sourceCode"><SPAN class="sh_string">'www.google.com'</SPAN></CODE> и преобразовывающий обратно полученные адреса.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> dns <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'dns'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

dns<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">resolve4</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'www.google.com'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> addresses<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">throw</SPAN></SPAN> err<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

  console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'addresses: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> JSON<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>addresses<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>

  <SPAN class="sh_keyword"><SPAN class="sh_keyword">for</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i <SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN> addresses<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN> i<SPAN class="sh_symbol"><SPAN class="sh_symbol">++)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
    <SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> a <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> addresses<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN>i<SPAN class="sh_symbol"><SPAN class="sh_symbol">];</SPAN></SPAN>
    dns<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">reverse</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>a<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> domains<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
      <SPAN class="sh_keyword"><SPAN class="sh_keyword">if</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>err<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
        console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'reverse for '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> a <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">' failed: '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN>
          err<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>message<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
      <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">else</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
        console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'reverse for '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> a <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">': '</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN>
          JSON<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>domains<SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
      <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
    <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
  <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H3 id="dns-resolve-253">dns.resolve(domain, rrtype = 'A', callback)</H3>

<P>разрешает домен (например <CODE class="sh_sourceCode"><SPAN class="sh_string">'google.com'</SPAN></CODE>) в массив записей типа, указанного в rrtype. Допустимые значения rrtypes: <CODE class="sh_sourceCode">A</CODE> (адреса IPV4), <CODE class="sh_sourceCode">AAAA</CODE> (адреса IPV6), <CODE class="sh_sourceCode">MX</CODE> (записи mail exchange), <CODE class="sh_sourceCode">TXT</CODE> (текстовые записи), <CODE class="sh_sourceCode">SRV</CODE> (записи SRV), и <CODE class="sh_sourceCode">PTR</CODE> (используются для запросов домена по IP).</P>

<P>Обработчик принимает аргументы <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> addresses<SPAN class="sh_symbol">)</SPAN></CODE>.  Тип каждого элемента <CODE class="sh_sourceCode">addresses</CODE> определяется типом записи, и описан в документации по соответствующим методам запроса ниже.</P>

<P>При ошибке <CODE class="sh_sourceCode">err</CODE> будет экземпляром объекта <CODE class="sh_sourceCode"><SPAN class="sh_predef_func">Error</SPAN></CODE>, где <CODE class="sh_sourceCode">err<SPAN class="sh_symbol">.</SPAN>errno</CODE> &mdash; один из кодов ошибки перечисленных ниже и <CODE class="sh_sourceCode">err<SPAN class="sh_symbol">.</SPAN>message</CODE> строка, содержащая описание ошибки на английском.</P>

<H3 id="dns-resolve4-254">dns.resolve4(domain, callback)</H3>

<P>То же что <CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">resolve</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>, но только для IPv4 адресов (записи типа <CODE class="sh_sourceCode">A</CODE>).
<CODE class="sh_sourceCode">addresses</CODE> это массив IPv4 адресов (например <BR>
<CODE class="sh_sourceCode"><SPAN class="sh_symbol">[</SPAN><SPAN class="sh_string">'74.125.79.104'</SPAN><SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_string">'74.125.79.105'</SPAN><SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_string">'74.125.79.106'</SPAN><SPAN class="sh_symbol">]</SPAN></CODE>).</P>

<H3 id="dns-resolve6-255">dns.resolve6(domain, callback)</H3>

<P>То же что <CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">resolve4</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> но только для IPv6 адресов (записи типа <CODE class="sh_sourceCode">AAAA</CODE>).</P>

<H3 id="dns-resolvemx-256">dns.resolveMx(domain, callback)</H3>

<P>То же что <CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">resolve</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>, но только для MX-записей.</P>

<P><CODE class="sh_sourceCode">addresses</CODE> это массив MX записей, каждая с атрибутами priority и exchange (например <CODE class="sh_sourceCode"><SPAN class="sh_symbol">[</SPAN><SPAN class="sh_cbracket">{</SPAN><SPAN class="sh_string">'priority'</SPAN><SPAN class="sh_symbol">:</SPAN> <SPAN class="sh_number">10</SPAN><SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_string">'exchange'</SPAN><SPAN class="sh_symbol">:</SPAN> <SPAN class="sh_string">'mx.example.com'</SPAN><SPAN class="sh_cbracket">}</SPAN><SPAN class="sh_symbol">,...]</SPAN></CODE>).</P>

<H3 id="dns-resolvetxt-257">dns.resolveTxt(domain, callback)</H3>

<P>То же что <CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">resolve</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>, но только для текстовых записей (тип записи <CODE class="sh_sourceCode">TXT</CODE>).
<CODE class="sh_sourceCode">addresses</CODE> это массив текстовых записей, доступных для домена <CODE class="sh_sourceCode">domain</CODE> (например <CODE class="sh_sourceCode"><SPAN class="sh_symbol">[</SPAN><SPAN class="sh_string">'v=spf1 ip4:0.0.0.0 ~all'</SPAN><SPAN class="sh_symbol">]</SPAN></CODE>).</P>

<H3 id="dns-resolvesrv-258">dns.resolveSrv(domain, callback)</H3>

<P>То же, что <CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">resolve</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>, но только для service records (записей <CODE class="sh_sourceCode">SRV</CODE>).
<CODE class="sh_sourceCode">addresses</CODE> это массив SRV записей, доступных для домена <CODE class="sh_sourceCode">domain</CODE>. Свойства SRV записей: <CODE class="sh_sourceCode">'priority'</CODE>, <CODE class="sh_sourceCode">'weight'</CODE>, <CODE class="sh_sourceCode">'port'</CODE>, и <CODE class="sh_sourceCode">'name'</CODE> (например, <CODE class="sh_sourceCode"><SPAN class="sh_symbol">[</SPAN><SPAN class="sh_cbracket">{</SPAN><SPAN class="sh_string">'priority'</SPAN><SPAN class="sh_symbol">:</SPAN> <SPAN class="sh_number">10</SPAN><SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_cbracket">{</SPAN><SPAN class="sh_string">'weight'</SPAN><SPAN class="sh_symbol">:</SPAN> <SPAN class="sh_number">5</SPAN><SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_string">'port'</SPAN><SPAN class="sh_symbol">:</SPAN> <SPAN class="sh_number">21223</SPAN><SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_string">'name'</SPAN><SPAN class="sh_symbol">:</SPAN> <SPAN class="sh_string">'service.example.com'</SPAN><SPAN class="sh_cbracket">}</SPAN><SPAN class="sh_symbol">,</SPAN> <SPAN class="sh_symbol">...]</SPAN></CODE>).</P>

<H3 id="dns-reverse-259">dns.reverse(ip, callback)</H3>

<P>Обратно разрешает IP-адрес в массив доменных имён.</P>

<P>Аргументы обработчика: <CODE class="sh_sourceCode"><SPAN class="sh_symbol">(</SPAN>err<SPAN class="sh_symbol">,</SPAN> domains<SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<P>Если произошла ошибка, <CODE class="sh_sourceCode">err</CODE> будет ненулевым экземпляром объекта Error.</P>

<P>Каждый запрос к DNS может вернуть код ошибки.</P>

<UL>
<LI><CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN>TEMPFAIL</CODE>: таймаут, SERVFAIL или похожее.</LI>
<LI><CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN>PROTOCOL</CODE>: получен повреждённый ответ.</LI>
<LI><CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN>NXDOMAIN</CODE>: домен не существует.</LI>
<LI><CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN>NODATA</CODE>: домен существует, но нет данных требуемого типа.</LI>
<LI><CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN>NOMEM</CODE>: при обработке закончилась память.</LI>
<LI><CODE class="sh_sourceCode">dns<SPAN class="sh_symbol">.</SPAN>BADQUERY</CODE>: запрос неверно сформирован.</LI>
</UL>


<H2 id="assert-260">Assert</H2>

<P>Этот модуль используется для написания юнит-тестов для Ваших приложений, вы можете использовать его вызвав <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'assert'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE>.</P>

<H3 id="assert-fail-261">assert.fail(actual, expected, message, operator)</H3>

<P>Проверяет что <CODE class="sh_sourceCode">actual</CODE> соответствует <CODE class="sh_sourceCode">expected</CODE> используя указанный оператор.</P>

<H3 id="assert-ok-262">assert.ok(value, message)</H3>

<P>Проверяет что значение value равно <CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE>, то же самое что <CODE class="sh_sourceCode">assert<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">equal</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_keyword">true</SPAN><SPAN class="sh_symbol">,</SPAN> value<SPAN class="sh_symbol">,</SPAN> message<SPAN class="sh_symbol">);</SPAN></CODE></P>

<H3 id="assert-equal-263">assert.equal(actual, expected, message)</H3>

<P>Неглубокая проверка на равенство с использованием соответствующего оператора ( <CODE class="sh_sourceCode"><SPAN class="sh_symbol">==</SPAN></CODE> ).</P>

<H3 id="assert-notequal-264">assert.notEqual(actual, expected, message)</H3>

<P>Неглубокая проверка на неравенство с использованием соответствующего оператора (<CODE class="sh_sourceCode"><SPAN class="sh_symbol">!=</SPAN></CODE> ).</P>

<H3 id="assert-deepequal-265">assert.deepEqual(actual, expected, message)</H3>

<P>Глубокая проверка на равенство.</P>

<H3 id="assert-notdeepequal-266">assert.notDeepEqual(actual, expected, message)</H3>

<P>Глубокая проверка на неравенство.</P>

<H3 id="assert-strictequal-267">assert.strictEqual(actual, expected, message)</H3>

<P>Проверка на строгое равенство, с использованием соответствующего оператора ( <CODE class="sh_sourceCode"><SPAN class="sh_symbol">===</SPAN></CODE> )</P>

<H3 id="assert-notstrictequal-268">assert.notStrictEqual(actual, expected, message)</H3>

<P>Проверка на строгое неравенство, с использованием соответствующего оператора ( <CODE class="sh_sourceCode"><SPAN class="sh_symbol">!==</SPAN></CODE> )</P>

<H3 id="assert-throws-269">assert.throws(block, error, message)</H3>

<P>Ожидает что блок кода <CODE class="sh_sourceCode">block</CODE> вызовет ошибку.</P>

<H3 id="assert-doesnotthrow-270">assert.doesNotThrow(block, error, message)</H3>

<P>Ожидает что блок кода <CODE class="sh_sourceCode">block</CODE> не вызовет ошибки.</P>

<H3 id="assert-iferror-271">assert.ifError(value)</H3>

<P>Проверяет что value имеет значение false, бросает исключение встретив true. Удобно для проверки первого аргумента функций-обработчиков, <CODE class="sh_sourceCode">error</CODE>.</P>

<H2 id="path-272">Path</H2>

<P>Этот модуль содержит средства для работы с путями. Используйте <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'path'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> чтобы получить к нему доступ.  Модуль предоставляет следующие методы:</P>

<H3 id="path-join-273">path.join(/<EM> path1, path2, ... </EM>/)</H3>

<P>Соединяет все аргументы и обрабатывает получившийся путь.  Например:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'path'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">join</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">...</SPAN></SPAN>   <SPAN class="sh_string"><SPAN class="sh_string">'/foo'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bar'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'baz/asdf'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'quux'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'..'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'/foo/bar/baz/asdf'</SPAN></SPAN>
</CODE></PRE>

<H3 id="path-normalizearray-274">path.normalizeArray(arr)</H3>

<P>Нормализует массив частей пути, обрабатывая <CODE class="sh_sourceCode"><SPAN class="sh_string">'..'</SPAN></CODE> и <CODE class="sh_sourceCode"><SPAN class="sh_string">'.'</SPAN></CODE>. Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">path<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">normalizeArray</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">([</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">''</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN>
  <SPAN class="sh_string"><SPAN class="sh_string">'foo'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bar'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'baz'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'asdf'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'quux'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'..'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">])</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// возвращает</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">''</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'foo'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bar'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'baz'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'asdf'</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN>
</CODE></PRE>

<H3 id="path-normalize-275">path.normalize(p)</H3>

<P>Нормализует строку пути, обрабатывая <CODE class="sh_sourceCode"><SPAN class="sh_string">'..'</SPAN></CODE> и <CODE class="sh_sourceCode"><SPAN class="sh_string">'.'</SPAN></CODE>.  Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">path<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">normalize</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/foo/bar/baz/asdf/quux/..'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// возвращает</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'/foo/bar/baz/asdf'</SPAN></SPAN>
</CODE></PRE>

<H3 id="path-dirname-276">path.dirname(p)</H3>

<P>Возвращает имя директории для пути. Действует как Unix-команда <CODE class="sh_sourceCode">dirname</CODE>.  Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">path<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">dirname</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/foo/bar/baz/asdf/quux'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// возвращает</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'/foo/bar/baz/asdf'</SPAN></SPAN>
</CODE></PRE>

<H3 id="path-basename-277">path.basename(p, ext)</H3>

<P>Возвращает последнюю часть пути.  Действует как Unix-команда <CODE class="sh_sourceCode">basename</CODE>.  Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">path<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">basename</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/foo/bar/baz/asdf/quux.html'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// возвращает</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'quux.html'</SPAN></SPAN>

path<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">basename</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/foo/bar/baz/asdf/quux.html'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'.html'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// возвращает</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'quux'</SPAN></SPAN>
</CODE></PRE>

<H3 id="path-extname-278">path.extname(p)</H3>

<P>Возвращает расширение пути.  Учитывается всё после последней '.' в последней части
пути.  Если в последней части нет '.' или '.' единственный символ, возвращает пустую строку.  Примеры:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">path<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">extname</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'index.html'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// returns </SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'.html'</SPAN></SPAN>

path<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">extname</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'index'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// returns</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">''</SPAN></SPAN>
</CODE></PRE>

<H3 id="path-exists-279">path.exists(p, callback)</H3>

<P>Проверяет, существует ли данный путь.  Вызывает переданный обработчик с аргументом true или false. Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">path<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">exists</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'/etc/passwd'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>exists<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  sys<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">debug</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>exists <SPAN class="sh_symbol"><SPAN class="sh_symbol">?</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">"it's there"</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">"no passwd!"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<H2 id="url-280">URL</H2>

<P>В это модуле собраны инструменты для разрешения и разбора URL.
Вызовите <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'url'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> чтобы его использовать.</P>

<P>Объекты разобранного URL имеют либо все либо некоторые из перечисленных полей, в зависимости от их
присутствия в строке URL. Части которых не было в URL не будут
присутствовать в объекте. Примеры показаны для URL</P>

<P><CODE class="sh_sourceCode"><SPAN class="sh_string">'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</SPAN></CODE></P>

<UL>
<LI><P><CODE class="sh_sourceCode">href</CODE></P>

<P>Полный URL который был разобран. Пример:
<CODE class="sh_sourceCode"><SPAN class="sh_string">'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">protocol</CODE></P>

<P>Протокол запроса.  Пример: <CODE class="sh_sourceCode"><SPAN class="sh_string">'http:'</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">host</CODE></P>

<P>Полный host, включая порт и информацию аутентификации. Пример:
<CODE class="sh_sourceCode"><SPAN class="sh_string">'user:pass@host.com:8080'</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">auth</CODE></P>

<P>Информация для аутентификации.  Example: <CODE class="sh_sourceCode"><SPAN class="sh_string">'user:pass'</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">hostname</CODE></P>

<P>Имя хоста.  Пример: <CODE class="sh_sourceCode"><SPAN class="sh_string">'host.com'</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">port</CODE></P>

<P>Номер порта. Пример: <CODE class="sh_sourceCode"><SPAN class="sh_string">'8080'</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">pathname</CODE></P>

<P>Секция пути, которая идёт после хоста и перед строкой параметров, включая начальный слеш если он есть.  Пример: <CODE class="sh_sourceCode"><SPAN class="sh_string">'/p/a/t/h'</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">search</CODE></P>

<P>Строка запроса, включая ведущий знак вопроса. Пример: <CODE class="sh_sourceCode"><SPAN class="sh_string">'?query=string'</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">query</CODE></P>

<P>Параметры из строки запроса, либо уже разобранный объект с параметрами. пример:
<CODE class="sh_sourceCode"><SPAN class="sh_string">'query=string'</SPAN></CODE> или <CODE class="sh_sourceCode"><SPAN class="sh_cbracket">{</SPAN><SPAN class="sh_string">'query'</SPAN><SPAN class="sh_symbol">:</SPAN><SPAN class="sh_string">'string'</SPAN><SPAN class="sh_cbracket">}</SPAN></CODE></P></LI>
<LI><P><CODE class="sh_sourceCode">hash</CODE></P>

<P>"Фрагмент" URL, включая знак решётки. Пример: <CODE class="sh_sourceCode"><SPAN class="sh_string">'#hash'</SPAN></CODE></P></LI>
</UL>


<P>Модуль URL предоставляет следующие методы:</P>

<H3 id="url-parse-281">url.parse(urlStr, parseQueryString=false)</H3>

<P>Получает строку URL и возвращает объект. Передайте <CODE class="sh_sourceCode"><SPAN class="sh_keyword">true</SPAN></CODE> вторым аргументом чтобы одновременно разобрать строку запроса модулем <CODE class="sh_sourceCode">querystring</CODE>.</P>

<H3 id="url-format-282">url.format(urlObj)</H3>

<P>Получает объект URL и возвращает отформатированный URL в виде строки.</P>

<H3 id="url-resolve-283">url.resolve(from, to)</H3>

<P>Получает базовый URL и относительный URL, и разрешает их как это сделал бы браузер для гиперссылки.</P>

<H2 id="query-string-284">Строка запроса</H2>

<P>Этот модуль предоставляет инструменты для работы со строкой запроса.  Он предоставляет следующие методы:</P>

<H3 id="querystring-stringify-285">querystring.stringify(obj, sep='&amp;', eq='=', munge=true)</H3>

<P>Сериализует объект в строку запроса.  Можно менять символы разделителя и присваивания.
Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">querystring<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bar'</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// вернёт</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'foo=bar'</SPAN></SPAN>

querystring<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bar'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> baz<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bob'</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">';'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">':'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// вернёт</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'foo:bar;baz:bob'</SPAN></SPAN>
</CODE></PRE>

<P>По умолчанию, эта функция будет преобразовывать параметры для массивов и объектов в стиле PHP/Rails.
Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">querystring<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bar'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'baz'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'boz'</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// вернёт</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'foo=boz'</SPAN></SPAN>

querystring<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>bar<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'baz'</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// вернёт</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'foo[bar]=baz'</SPAN></SPAN>
</CODE></PRE>

<P>Если Вы хотите избежать такого преобразования параметров (например, генерируя параметры для Java сервлета), вы можете передать в аргументе <CODE class="sh_sourceCode">munge</CODE> значение <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE>.
Пример:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">querystring<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">stringify</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'bar'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'baz'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> foo<SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'boz'</SPAN></SPAN><SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'&amp;'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'='</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">false</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// возвращает</SPAN></SPAN>
<SPAN class="sh_string"><SPAN class="sh_string">'foo=bar&amp;foo=baz&amp;foo=boz'</SPAN></SPAN>
</CODE></PRE>

<P>Заметьте что когда <CODE class="sh_sourceCode">munge</CODE> выставлено в <CODE class="sh_sourceCode"><SPAN class="sh_keyword">false</SPAN></CODE>, имена параметров для объектов всё равно будут преобразованы.</P>

<H3 id="querystring-parse-286">querystring.parse(str, sep='&amp;', eq='=')</H3>

<P>Десериализует строку запроса в объект. Можно задавать собственные символы разделителя и присваивания.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">querystring<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">parse</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'a=b&amp;b=c'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_comment"><SPAN class="sh_comment">// возвращает</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'a'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'b'</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'b'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">:</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'c'</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>
<P>Эта функция может разбирать также преобразованные строки запроса (см. <CODE class="sh_sourceCode">stringify</CODE>)</P>

<H3 id="querystring-escape-287">querystring.escape</H3>

<P>Функция экранирования, используемая в <CODE class="sh_sourceCode">querystring<SPAN class="sh_symbol">.</SPAN>stringify</CODE>, предоставляется для того чтобы проще было заменить её собственной.</P>

<H3 id="querystring-unescape-288">querystring.unescape</H3>

<P>Функция декодирования, используемая <CODE class="sh_sourceCode">querystring<SPAN class="sh_symbol">.</SPAN>parse</CODE>, предоставляется для того чтобы проще было заменить её собственной.</P>

<!--<H2 id="repl-289">REPL</H2>

<P>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily
includable in other programs.  REPL provides a way to interactively run
JavaScript and see the results.  It can be used for debugging, testing, or
just trying things out.</P>

<P>By executing <CODE class="sh_sourceCode">node</CODE> without any arguments from the command-line you will be
dropped into the REPL. It has simplistic emacs line-editting.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">mjr<SPAN class="sh_symbol"><SPAN class="sh_symbol">:~</SPAN></SPAN>$ node
Type <SPAN class="sh_string"><SPAN class="sh_string">'.help'</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">for</SPAN></SPAN> options<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>
node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> a <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">2</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">3</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">];</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">2</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">3</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN>
node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> a<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">forEach</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>v<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">...</SPAN></SPAN>   console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>v<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">...</SPAN></SPAN>   <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN>
<SPAN class="sh_number"><SPAN class="sh_number">2</SPAN></SPAN>
<SPAN class="sh_number"><SPAN class="sh_number">3</SPAN></SPAN>
</CODE></PRE>

<P>For advanced line-editors, start node with the environmental variable <CODE class="sh_sourceCode">NODE_NO_READLINE<SPAN class="sh_symbol">=</SPAN><SPAN class="sh_number">1</SPAN></CODE>.
This will start the REPL in canonical terminal settings which will allow you to use with <CODE class="sh_sourceCode">rlwrap</CODE>.</P>

<P>For example, you could add this to your bashrc file:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">alias node<SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"env NODE_NO_READLINE=1 rlwrap node"</SPAN></SPAN>
</CODE></PRE>

<H3 id="repl-start-290">repl.start(prompt, stream)</H3>

<P>Starts a REPL with <CODE class="sh_sourceCode">prompt</CODE> as the prompt and <CODE class="sh_sourceCode">stream</CODE> for all I/O.  <CODE class="sh_sourceCode">prompt</CODE>
is optional and defaults to <CODE class="sh_sourceCode">node<SPAN class="sh_symbol">&gt;</SPAN></CODE>.  <CODE class="sh_sourceCode">stream</CODE> is optional and defaults to
<CODE class="sh_sourceCode">process<SPAN class="sh_symbol">.</SPAN><SPAN class="sh_function">openStdin</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.</P>

<P>Multiple REPLs may be started against the same running instance of node.  Each
will share the same global object but will have unique I/O.</P>

<P>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> net <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"net"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
    repl <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"repl"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

connections <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">0</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

repl<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">start</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"node via stdin&gt; "</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

net<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">createServer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>socket<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  connections <SPAN class="sh_symbol"><SPAN class="sh_symbol">+=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  repl<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">start</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"node via Unix socket&gt; "</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> socket<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">listen</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"/tmp/node-repl-sock"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>

net<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">createServer</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>socket<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  connections <SPAN class="sh_symbol"><SPAN class="sh_symbol">+=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  repl<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">start</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"node via TCP socket&gt; "</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> socket<SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">).</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">listen</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">5001</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
</CODE></PRE>

<P>Running this program from the command line will start a REPL on stdin.  Other
REPL clients may connect through the Unix socket or TCP socket. <CODE class="sh_sourceCode">telnet</CODE> is useful
for connecting to TCP sockets, and <CODE class="sh_sourceCode">socat</CODE> can be used to connect to both Unix and
TCP sockets.</P>

<P>By starting a REPL from a Unix socket-based server instead of stdin, you can
connect to a long-running node process without restarting it.</P>

<H3 id="repl-features-291">Возможности REPL</H3>

<P>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.</P>

<P>The special variable <CODE class="sh_sourceCode">_</CODE> (underscore) contains the result of the last expression.</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">"a"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">"b"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">"c"</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN>
<SPAN class="sh_symbol"><SPAN class="sh_symbol">[</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'a'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'b'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'c'</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">]</SPAN></SPAN>
node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> _<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>length
<SPAN class="sh_number"><SPAN class="sh_number">3</SPAN></SPAN>
node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> _ <SPAN class="sh_symbol"><SPAN class="sh_symbol">+=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">1</SPAN></SPAN>
<SPAN class="sh_number"><SPAN class="sh_number">4</SPAN></SPAN>
</CODE></PRE>

<P>The REPL provides access to any variables in the global scope. You can expose a variable
to the REPL explicitly by assigning it to the <CODE class="sh_sourceCode">scope</CODE> object associated with each
<CODE class="sh_sourceCode">REPLServer</CODE>.  For example:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_comment"><SPAN class="sh_comment">// repl_test.js</SPAN></SPAN>
<SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> repl <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"repl"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN>
    msg <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">"message"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

repl<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">start</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">().</SPAN></SPAN>scope<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>m <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> msg<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
</CODE></PRE>

<P>Things in the <CODE class="sh_sourceCode">scope</CODE> object appear as local within the REPL:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">mjr<SPAN class="sh_symbol"><SPAN class="sh_symbol">:~</SPAN></SPAN>$ node repl_test<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>js
node<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> m
<SPAN class="sh_string"><SPAN class="sh_string">'message'</SPAN></SPAN>
</CODE></PRE>

<P>There are a few special REPL commands:</P>

<UL>
<LI><P><CODE class="sh_sourceCode"><SPAN class="sh_symbol">.</SPAN><SPAN class="sh_keyword">break</SPAN></CODE> - While inputting a multi-line expression, sometimes you get lost or just don't care
about completing it.  <CODE class="sh_sourceCode"><SPAN class="sh_symbol">.</SPAN><SPAN class="sh_keyword">break</SPAN></CODE> will start over.</P></LI>
<LI><P><CODE class="sh_sourceCode"><SPAN class="sh_symbol">.</SPAN>clear</CODE> - Resets the <CODE class="sh_sourceCode">scope</CODE> object to an empty object and clears any multi-line expression.</P></LI>
<LI><P><CODE class="sh_sourceCode"><SPAN class="sh_symbol">.</SPAN>exit</CODE> - Close the I/O stream, which will cause the REPL to exit.</P></LI>
<LI><P><CODE class="sh_sourceCode"><SPAN class="sh_symbol">.</SPAN>help</CODE> - Show this list of special commands.</P></LI>
</UL>


<H2 id="modules-292">Modules</H2>

<P>Node uses the CommonJS module system.</P>

<P>Node has a simple module loading system.  In Node, files and modules are in
one-to-one correspondence.  As an example, <CODE class="sh_sourceCode">foo<SPAN class="sh_symbol">.</SPAN>js</CODE> loads the module
<CODE class="sh_sourceCode">circle<SPAN class="sh_symbol">.</SPAN>js</CODE> in the same directory.</P>

<P>The contents of <CODE class="sh_sourceCode">foo<SPAN class="sh_symbol">.</SPAN>js</CODE>:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> circle <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_function"><SPAN class="sh_function">require</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'./circle'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">);</SPAN></SPAN>
console<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">log</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'The area of a circle of radius 4 is '</SPAN></SPAN>
           <SPAN class="sh_symbol"><SPAN class="sh_symbol">+</SPAN></SPAN> circle<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">area</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_number"><SPAN class="sh_number">4</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
</CODE></PRE>

<P>The contents of <CODE class="sh_sourceCode">circle<SPAN class="sh_symbol">.</SPAN>js</CODE>:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode"><SPAN class="sh_keyword"><SPAN class="sh_keyword">var</SPAN></SPAN> PI <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">3.14</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

exports<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>area <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>r<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">return</SPAN></SPAN> PI <SPAN class="sh_symbol"><SPAN class="sh_symbol">*</SPAN></SPAN> r <SPAN class="sh_symbol"><SPAN class="sh_symbol">*</SPAN></SPAN> r<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

exports<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>circumference <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_keyword"><SPAN class="sh_keyword">function</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>r<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN> <SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  <SPAN class="sh_keyword"><SPAN class="sh_keyword">return</SPAN></SPAN> <SPAN class="sh_number"><SPAN class="sh_number">2</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">*</SPAN></SPAN> PI <SPAN class="sh_symbol"><SPAN class="sh_symbol">*</SPAN></SPAN> r<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
</CODE></PRE>

<P>The module <CODE class="sh_sourceCode">circle<SPAN class="sh_symbol">.</SPAN>js</CODE> has exported the functions <CODE class="sh_sourceCode"><SPAN class="sh_function">area</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> and
<CODE class="sh_sourceCode"><SPAN class="sh_function">circumference</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.  To export an object, add to the special <CODE class="sh_sourceCode">exports</CODE>
object.  (Alternatively, one can use <CODE class="sh_sourceCode"><SPAN class="sh_keyword">this</SPAN></CODE> instead of <CODE class="sh_sourceCode">exports</CODE>.) Variables
local to the module will be private. In this example the variable <CODE class="sh_sourceCode">PI</CODE> is
private to <CODE class="sh_sourceCode">circle<SPAN class="sh_symbol">.</SPAN>js</CODE>. The function <CODE class="sh_sourceCode"><SPAN class="sh_function">puts</SPAN><SPAN class="sh_symbol">()</SPAN></CODE> comes from the module <CODE class="sh_sourceCode"><SPAN class="sh_string">'sys'</SPAN></CODE>,
which is a built-in module. Modules which are not prefixed by <CODE class="sh_sourceCode"><SPAN class="sh_string">'./'</SPAN></CODE> are
built-in module--more about this later.</P>

<P>A module prefixed with <CODE class="sh_sourceCode"><SPAN class="sh_string">'./'</SPAN></CODE> is relative to the file calling <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">()</SPAN></CODE>.
That is, <CODE class="sh_sourceCode">circle<SPAN class="sh_symbol">.</SPAN>js</CODE> must be in the same directory as <CODE class="sh_sourceCode">foo<SPAN class="sh_symbol">.</SPAN>js</CODE> for
<CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'./circle'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> to find it.</P>

<P>Without the leading <CODE class="sh_sourceCode"><SPAN class="sh_string">'./'</SPAN></CODE>, like <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'assert'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> the module is searched
for in the <CODE class="sh_sourceCode">require<SPAN class="sh_symbol">.</SPAN>paths</CODE> array. <CODE class="sh_sourceCode">require<SPAN class="sh_symbol">.</SPAN>paths</CODE> on my system looks like
this:</P>

<P><CODE class="sh_sourceCode"><SPAN class="sh_symbol">[</SPAN> <SPAN class="sh_string">'/home/ryan/.node_libraries'</SPAN> <SPAN class="sh_symbol">]</SPAN></CODE></P>

<P>That is, when <CODE class="sh_sourceCode"><SPAN class="sh_function">require</SPAN><SPAN class="sh_symbol">(</SPAN><SPAN class="sh_string">'assert'</SPAN><SPAN class="sh_symbol">)</SPAN></CODE> is called Node looks for:</P>

<UL>
<LI>1: <CODE class="sh_sourceCode"><SPAN class="sh_regexp">/home/</SPAN><SPAN class="sh_normal">ryan</SPAN><SPAN class="sh_symbol">/.</SPAN><SPAN class="sh_normal">node_libraries</SPAN><SPAN class="sh_symbol">/</SPAN>assert<SPAN class="sh_symbol">.</SPAN>js</CODE></LI>
<LI>2: <CODE class="sh_sourceCode"><SPAN class="sh_regexp">/home/</SPAN><SPAN class="sh_normal">ryan</SPAN><SPAN class="sh_symbol">/.</SPAN><SPAN class="sh_normal">node_libraries</SPAN><SPAN class="sh_symbol">/</SPAN>assert<SPAN class="sh_symbol">.</SPAN>node</CODE></LI>
<LI>3: <CODE class="sh_sourceCode"><SPAN class="sh_regexp">/home/</SPAN><SPAN class="sh_normal">ryan</SPAN><SPAN class="sh_symbol">/.</SPAN><SPAN class="sh_normal">node_libraries</SPAN><SPAN class="sh_symbol">/</SPAN><SPAN class="sh_normal">assert</SPAN><SPAN class="sh_symbol">/</SPAN>index<SPAN class="sh_symbol">.</SPAN>js</CODE></LI>
<LI>4: <CODE class="sh_sourceCode"><SPAN class="sh_regexp">/home/</SPAN><SPAN class="sh_normal">ryan</SPAN><SPAN class="sh_symbol">/.</SPAN><SPAN class="sh_normal">node_libraries</SPAN><SPAN class="sh_symbol">/</SPAN><SPAN class="sh_normal">assert</SPAN><SPAN class="sh_symbol">/</SPAN>index<SPAN class="sh_symbol">.</SPAN>node</CODE></LI>
</UL>


<P>interrupting once a file is found. Files ending in <CODE class="sh_sourceCode"><SPAN class="sh_string">'.node'</SPAN></CODE> are binary Addon
Modules; see 'Addons' below. <CODE class="sh_sourceCode"><SPAN class="sh_string">'index.js'</SPAN></CODE> allows one to package a module as
a directory.</P>

<P><CODE class="sh_sourceCode">require<SPAN class="sh_symbol">.</SPAN>paths</CODE> can be modified at runtime by simply unshifting new
paths onto it, or at startup with the <CODE class="sh_sourceCode">NODE_PATH</CODE> environmental
variable (which should be a list of paths, colon separated).</P>-->

<H2 id="addons-293">Дополнения</H2>

<P>Дополнения &mdash; это динамически подключаемые объекты. Они могут предоставлять связь с библиотеками на языках C/C++.
На данный момент API для дополнения довольно сложное и использует следующие библиотеки:</P>

<UL>
<LI><P>Движок V8 JavaScript, написан на C++. Используется для обращения к JavaScript из дополнения:
создания объектов, вызова функций и т.д. Документация по нему крайне скудна, в основнос тоит полагаться на заголовочный файл
<CODE class="sh_sourceCode">v8<SPAN class="sh_symbol">.</SPAN>h</CODE> (<CODE class="sh_sourceCode"><SPAN class="sh_normal">deps</SPAN><SPAN class="sh_symbol">/</SPAN><SPAN class="sh_normal">v8</SPAN><SPAN class="sh_symbol">/</SPAN><SPAN class="sh_normal">include</SPAN><SPAN class="sh_symbol">/</SPAN>v8<SPAN class="sh_symbol">.</SPAN>h</CODE> в дистрибутиве Node).</P></LI>
<LI><P>libev, библиотеку обработки цикла событий на C. Каждый раз, когда вам потребуется подождать пока файловый дескриптор станет доступен для чтения,
подождать вызова таймера или поступления сигнала, вы будете испльзовать вызовы из libev. Соответственно, вам придётся использовать  libev для любых операций ввода/вывода. Node использует цикл событий <CODE class="sh_sourceCode">EV_DEFAULT</CODE>. Документация доступна на <A HREF="http:/cvs.schmorp.de/libev/ev.html">сайте автора</A>.</P></LI>
<LI><P>libeio, библиотеку пула потоков на C. Она используется для выполнения блокирующих вызовов POSIX асинхронно, в отдельных потоках. Для большинства вызовов существуют стандартные обёртки, которые вы можете найти в заголовочном файле
<CODE class="sh_sourceCode"><SPAN class="sh_normal">src</SPAN><SPAN class="sh_symbol">/</SPAN>file<SPAN class="sh_symbol">.</SPAN>cc</CODE> so you will probably not need to use it. If you do need it,
<CODE class="sh_sourceCode"><SPAN class="sh_normal">deps</SPAN><SPAN class="sh_symbol">/</SPAN><SPAN class="sh_normal">libeio</SPAN><SPAN class="sh_symbol">/</SPAN>eio<SPAN class="sh_symbol">.</SPAN>h</CODE>.</P></LI>
<LI><P>Внутренние библиотеки Node. Наиюолее важная из них &mdash; класс <CODE class="sh_sourceCode">node<SPAN class="sh_symbol">::</SPAN>ObjectWrap</CODE>, от которого будут наследоваться большинство ваших классов.</P></LI>
<LI><P>Другое. Остальные доступные библиотеки вы можете найти впапке <CODE class="sh_sourceCode"><SPAN class="sh_normal">deps</SPAN><SPAN class="sh_symbol">/</SPAN></CODE> дистрибутива Node.</P></LI>
</UL>


<P>При сборке Node все её зависимости статически компилируются в исполняемый файл. При сборке своего модуля вы не должны задумываться об описанных выше библиотеках.</P>

<P>В качестве простого примера сделаем дополнение для Node на C++, которое будет делать тоже самое, что и JavaScript код:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">exports<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>hello <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'world'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
</CODE></PRE>

<P>Создадим файл <CODE class="sh_sourceCode">hello<SPAN class="sh_symbol">.</SPAN>cc</CODE>:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">#include <SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN>v8<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>h<SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN>

using namespace v8<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>

extern <SPAN class="sh_string"><SPAN class="sh_string">'C'</SPAN></SPAN> void
<SPAN class="sh_function"><SPAN class="sh_function">init</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>Handle<SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN><SPAN class="sh_predef_func"><SPAN class="sh_predef_func">Object</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> target<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">{</SPAN></SPAN>
  HandleScope scope<SPAN class="sh_symbol"><SPAN class="sh_symbol">;</SPAN></SPAN>
  target<SPAN class="sh_symbol"><SPAN class="sh_symbol">-&gt;</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">Set</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_predef_func"><SPAN class="sh_predef_func">String</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">::</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">New</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"hello"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">),</SPAN></SPAN> <SPAN class="sh_predef_func"><SPAN class="sh_predef_func">String</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">::</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">New</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">"World"</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">));</SPAN></SPAN>
<SPAN class="sh_cbracket"><SPAN class="sh_cbracket">}</SPAN></SPAN>
</CODE></PRE>

<P>Этот код нужно собрать в файл <CODE class="sh_sourceCode">hello<SPAN class="sh_symbol">.</SPAN>node</CODE>, файл бинарного дополнения.
Для этого создадим файл <CODE class="sh_sourceCode">wscript</CODE>, содержащий код на Python (аналог Makefile):</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">srcdir <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'.'</SPAN></SPAN>
blddir <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'build'</SPAN></SPAN>
VERSION <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'0.0.1'</SPAN></SPAN>

def <SPAN class="sh_function"><SPAN class="sh_function">set_options</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>opt<SPAN class="sh_symbol"><SPAN class="sh_symbol">):</SPAN></SPAN>
  opt<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">tool_options</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'compiler_cxx'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>

def <SPAN class="sh_function"><SPAN class="sh_function">configure</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>conf<SPAN class="sh_symbol"><SPAN class="sh_symbol">):</SPAN></SPAN>
  conf<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">check_tool</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'compiler_cxx'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
  conf<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">check_tool</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'node_addon'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>

def <SPAN class="sh_function"><SPAN class="sh_function">build</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>bld<SPAN class="sh_symbol"><SPAN class="sh_symbol">):</SPAN></SPAN>
  obj <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> bld<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN><SPAN class="sh_function"><SPAN class="sh_function">new_task_gen</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN><SPAN class="sh_string"><SPAN class="sh_string">'cxx'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'shlib'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">,</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'node_addon'</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
  obj<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>target <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'hello'</SPAN></SPAN>
  obj<SPAN class="sh_symbol"><SPAN class="sh_symbol">.</SPAN></SPAN>source <SPAN class="sh_symbol"><SPAN class="sh_symbol">=</SPAN></SPAN> <SPAN class="sh_string"><SPAN class="sh_string">'hello.cc'</SPAN></SPAN>
</CODE></PRE>

<P>Теперь можно запустить команду <CODE class="sh_sourceCode">node<SPAN class="sh_symbol">-</SPAN>waf configure build</CODE>, которая создаст файл 
<CODE class="sh_sourceCode"><SPAN class="sh_normal">build</SPAN><SPAN class="sh_symbol">/</SPAN><SPAN class="sh_keyword">default</SPAN><SPAN class="sh_symbol">/</SPAN>hello<SPAN class="sh_symbol">.</SPAN>node</CODE>, содержащий бинарную версию дополнения.</P>

<P><CODE class="sh_sourceCode">node<SPAN class="sh_symbol">-</SPAN>waf</CODE> &mdash; расширение <A HREF="http://code.google.com/p/waf/">WAF</A>, системы сборки на Python. <CODE class="sh_sourceCode">node<SPAN class="sh_symbol">-</SPAN>waf</CODE> включён в состав Node для упрощения процесса сборки дополнений.</P>

<P>Каждое дополнение должно содержать функцию <CODE class="sh_sourceCode">init</CODE> со следующим интерфейсом:</P>

<PRE class="sh_sourceCode"><CODE class="sh_sourceCode">extern <SPAN class="sh_string"><SPAN class="sh_string">'C'</SPAN></SPAN> void <SPAN class="sh_function"><SPAN class="sh_function">init</SPAN></SPAN> <SPAN class="sh_symbol"><SPAN class="sh_symbol">(</SPAN></SPAN>Handle<SPAN class="sh_symbol"><SPAN class="sh_symbol">&lt;</SPAN></SPAN><SPAN class="sh_predef_func"><SPAN class="sh_predef_func">Object</SPAN></SPAN><SPAN class="sh_symbol"><SPAN class="sh_symbol">&gt;</SPAN></SPAN> target<SPAN class="sh_symbol"><SPAN class="sh_symbol">)</SPAN></SPAN>
</CODE></PRE>

<P>Пока это вся документация по дополнениям. В качестве примера вы можете просмотреть код дополнения <A href="http://github.com/ry/node_postgres">http://github.com/ry/node_postgres</A>.</P>

<p>Оригинальная документация: <a href="http://nodejs.org">nodejs.org</a>. Перевод: <a href="http://kuroikaze85.wordpress.com">Сергей Широков</a> и <a href="http://nodejs.ru">Nodejs.ru</a>.</p>

<p>Поучаствовать в переводе можно <a href="http://github.com/kurokikaze/nodejs-docs-rus">на Github</a></p>
</DIV>
</DIV>
<SCRIPT type="text/javascript" src="api-files/jquery.js"></SCRIPT>
<SCRIPT type="text/javascript" src="api-files/sh_main.js"></SCRIPT>
<SCRIPT type="text/javascript" src="api-files/sh_javascript.min.js"></SCRIPT>
<SCRIPT type="text/javascript" src="api-files/doc.js"></SCRIPT>
<!-- Yandex.Metrika -->
</BODY></HTML>
